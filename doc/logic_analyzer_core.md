## Overview
The Logic Analyzer core allows for debugging logic by capturing a set of digital signals to memory. This is done in response to a ___trigger___ condition, which starts a ___capture___, which continues until the onboard memory is full. The resulting data is then read out to the host machine, and can be displayed as a waveform, exported as a CSV file, or turned into a synthesizable playback module.

This is very similar to the behavior of a benchtop logic analyzer, but Manta's Logic Analyzer Core includes some extra features you may find useful. Both the [Use Cases](../use_cases) page and the repository's [examples](https://github.com/fischermoseley/manta/tree/main/examples) folder contain examples of the Logic Analyzer Core for your reference.




## Configuration

As explained in the [getting started](../getting_started) page, the Logic Analyzer Core must be configured and included in the FPGA design before it can be operated. Configuration is performed differently depending on if you're using a traditional Verilog-based workflow, or if you're building an Amaranth-native design.

### Verilog-Based Workflows

Cores are configured with an entry in a project's configuration file when using a Verilog-based workflow, and the Logic Analyzer Core is no different. This is best shown by example:

```yaml
---
cores:
  my_logic_analyzer:
    type: logic_analyzer
    sample_depth: 4096
    trigger_location: 1000

    probes:
      larry: 1
      curly: 3
      moe: 9

    triggers:
      - moe RISING
      - curly FALLING
```
Inside this configuration, the following parameters may be set:

- `name`_(required)_: The name of the Logic Analyzer core, which is used when working with the API.
- `type`_(required)_: This denotes that this is a Logic Analyzer core. All cores contain a `type` field, which must be set to `logic_analyzer` to be recognized as an Logic Analyzer core.
- `sample_depth`_(required)_: The number of samples saved in the capture. A larger sample depth will use more FPGA resources, but will show what the probes are doing over a longer time interval.
- `probes` _(required)_: The signals in your logic that the Logic Analyzer connects to. Each probe is specified with a name and a width.

!!! warning "Name things carefully!"

    The names of the core and its probes are referenced in the autogenerated Verilog. This means that while the names can be arbitrary, they must be unique within your project and not contain any characters that your synthesis engine won't appreciate.

### Triggers
Triggers are the conditions that your logic must meet in order to start a capture, and they're specified under the `triggers` entry in the config file. Manta's triggers are reprogrammable, meaning you don't need to rebuild your source code to change the trigger condition - just updating the configuration file is enough. If multiple triggers are provided, any one trigger being met will trigger the entire core.

Each individual trigger is specified with the following structure:

`[probe]` `[operation]` `[argument]`

- __probe__: The probe that the trigger applies to. Each probe only supports one trigger on it. For instance, in the example above we couldn't add a trigger for `curly LEQ 4`, since we've already assigned a trigger to `curly`.

- __operation__: The logical operation to perform. Manta supports the following operations:
    - `RISING`, which checks if the probe has increased in value since the last clock cycle.
    - `FALLING`, which checks if the probe has decreased in value since the last clock cycle.
    - `CHANGING`, which checks if the probe is changed in value since the last clock cycle.

    These operations only compare a probe's value with itself, but sometimes it is useful to compare a probe's value to a constant. Manta provides a operations for doing such, including:

    - `GT`,  for greater than.
    - `LT`,  for less than.
    - `GEQ`, for greater than or equal to.
    - `LEQ`, for less than or equal to.
    - `EQ`, for equal to.
    - `NEQ`, for not equal to.

    These operations require a constant to compare against, referred to as an _argument_, which is described below:

- __argument__: A constant to compare against, if the operation specified requires one. On the FPGA, the argument will have just as many bits as the probe width.


### Trigger Location (optional)
Sometimes, you care more about what happens before a trigger is met than afterwards, or vice versa. To accommodate this, the logic analyzer has an optional _Trigger Location_ parameter, which sets when probe data is captured relative to the trigger condition being met. This is specified with the `trigger_position` entry in the configuration file, which sets how many samples to save prior to the trigger condition occurring. This is similar to a "holdoff" option on a traditional oscilloscope or logic analyzer.

If `trigger_position` is not specified, Manta will default to centering the capture window around the trigger condition. This results in just as many samples before the trigger as after.

### Trigger Modes (optional)
The logic analyzer has a few different ways of capturing data, which are represented by the _trigger modes_ below:

- __Single-Shot__: Once the trigger condition is met, record the value of the probes on every clock cycle in a continuous single shot.
- __Incremental__: Record samples when the trigger condition is met, but __don't__ record the samples when the trigger condition is not met. This is super useful for applications like audio processing or memory controllers, where there are many system clock cycles between signals of interest.
- __Immediate__: Record the value of the probes on every clock cycle, beginning immediately, and regardless of if the trigger condition is met. This is useful for investigating cases where a trigger condition is never being met (such as latchup or deadlock conditions) or obtaining a random snapshot of the FPGA's state.

Most logic analyzers use a single-shot capture by default, so Manta will do the same if no `trigger_mode` entry is provided in the project's configuration file.

## Usage

### Capturing Data

Once you have your Logic Analyzer core on the FPGA, you can capture data with:

```bash
manta capture [config_file] [la_core_name] [output path] [[additional output paths]...]
```
The capture may be exported as either a VCD or CSV file. If `manta.yaml` contained the configuration at the top of this page, then the following would export a .vcd file containing the captured waveform:

```bash
manta capture manta.yaml my_logic_analyzer capture.vcd
```

This will reset your logic analyzer, configure it with the triggers specified in `manta.yaml`, perform a capture, and create the file. Additional output files may be passed as well - Manta will detect the file format based on the extension (`.vcd`, `.csv`). Verilog (`.v`) files are also supported, and will follow the playback mechanism [described below](#playback).


### Playback

Manta has the ability to generate a module that _plays back_ a set of data captured from a Logic Analyzer core. This module has a set of outputs matching the inputs of the Logic Analyzer, which when enabled, will take the exact values captured by the logic analyzer. This module is synthesizable, and can either be used in simulation or included in the FPGA design.

If the file `manta.yaml` contained the configuration above, then running:
```bash
manta capture manta.yaml my_logic_analyzer capture.v
```

Generates a Verilog module at `capture.v` which can then be instantiated in the testbench or FPGA design in which it is needed.

This is useful for two situations in particular:

- _Input Verification._ Designs will often work in simulation, but fail in hardware. In the absence of any build errors, this usually means that the inputs being applied to the logic in simulation don't accurately represent those being applied to the logic in the real world. Playing signals back in simulation allows for easy comparison between simulated and measured input, and provides a nice way to check that the logic downstream is behaves properly.

- _Sparse Sampling._ Sometimes designs will have a small number of inputs, but a huge amount of internal state. In situations like these, it may be more efficient to sample the inputs and simulate the logic, instead of directly sampling the state. For instance, debugging a misbehaving branch predictor in a CPU can be done by recording activity on the address and data busses and playing them back in simulation - which would use less FPGA resources than sampling the entire pattern history table.

## Python API Documentation

::: manta.LogicAnalyzerCore

::: manta.LogicAnalyzerCapture

::: manta.LogicAnalyzerPlayback