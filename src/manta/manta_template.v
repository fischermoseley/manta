`default_nettype none
`timescale 1ns / 1ps

/*
This manta definition was autogenerated on @TIMESTAMP by @USER

If this breaks or if you've got dank formal verification memes,
please contact fischerm [at] mit.edu.
*/

`define IDLE 0
`define ARM 1
`define FILL 2
`define DOWNLINK 3

`define ARM_BYTE 8'b00110000

module manta (
    input wire clk,
    input wire rst,

    /* Begin autogenerated probe definitions */
    @PROBES
    /* End autogenerated probe definitions */

    input wire rxd,
    output reg txd);

    /* Begin autogenerated parameters */
    localparam SAMPLE_WIDTH = @SAMPLE_WIDTH;
    localparam SAMPLE_DEPTH = @SAMPLE_DEPTH;

    localparam DATA_WIDTH = @DATA_WIDTH;
    localparam BAUDRATE = @BAUDRATE;
    localparam CLK_FREQ_HZ = @CLK_FREQ_HZ;

    reg trigger;
    assign trigger = @TRIGGER;

    reg [SAMPLE_WIDTH - 1 : 0] concat;
    assign concat = @CONCAT;
    /* End autogenerated parameters */


    // FIFO
    reg [7:0] fifo_data_in;
    reg fifo_input_ready;

    reg fifo_request_output;
    reg [7:0] fifo_data_out;
    reg fifo_output_valid;

    reg [11:0] fifo_size;
    reg fifo_empty;
    reg fifo_full;

    fifo #(
        .WIDTH(SAMPLE_WIDTH),
        .DEPTH(SAMPLE_DEPTH)
    ) fifo (
        .clk(clk),
        .rst(rst),

        .data_in(fifo_data_in),
        .input_ready(fifo_input_ready),

        .request_output(fifo_request_output),
        .data_out(fifo_data_out),
        .output_valid(fifo_output_valid),

        .size(fifo_size),
        .empty(fifo_empty),
        .full(fifo_full));

    // Serial interface
    reg tx_start;
    reg [7:0] tx_data;
    reg tx_busy;

    reg [7:0] rx_data;
    reg rx_ready;
    reg rx_busy;


    uart_tx #(
		.DATA_WIDTH(DATA_WIDTH),
		.CLK_FREQ_HZ(CLK_FREQ_HZ),
		.BAUDRATE(BAUDRATE))
		tx (
		.clk(clk),
		.rst(rst),
		.start(tx_start),
		.data(tx_data),

		.busy(tx_busy),
		.txd(txd));

    uart_rx #(
		.DATA_WIDTH(DATA_WIDTH),
		.CLK_FREQ_HZ(CLK_FREQ_HZ),
		.BAUDRATE(BAUDRATE))
		rx (
		.clk(clk),
		.rst(rst),
		.rxd(rxd),

		.data(rx_data),
		.ready(rx_ready),
		.busy(rx_busy));


    /* State Machine */
    /*

    IDLE:
        - literally nothing is happening. the FIFO isn't being written to or read from. it should be empty.
        - an arm command over serial is what brings us into the ARM state

    ARM:
        - popping things onto FIFO. if the fifo is halfway full, we pop them off too.
        - meeting the trigger condition is what moves us into the filing state

    FILL:
        - popping things onto FIFO, until it's full. once it is full, we move into the downlinking state

    DOWNLINK:
        - popping thing off of the FIFO until it's empty. once it's empty, we move back into the IDLE state
    */

    /* Downlink State Machine Controller */
    /*

    - ila enters the downlink state
    - set fifo_output_request high for a clock cycle
    - when fifo_output_valid goes high, send fifo_data_out across the line
    - do nothing until tx_busy goes low
    - goto step 2

    */

    reg [1:0] state;
    reg [2:0] downlink_fsm_state;

    always @(posedge clk) begin
        if(rst) begin
            state <= `IDLE;
            downlink_fsm_state <= 0;
            tx_data <= 0;
            tx_start <= 0;
        end
        else begin

            case (state)
                `IDLE : begin
                    fifo_input_ready <= 0;
                    fifo_request_output <= 0;

                    if (rx_ready && rx_data == `ARM_BYTE) state <= `ARM;

                end

                `ARM : begin
                    // place samples into FIFO
                    fifo_input_ready <= 1;
                    fifo_data_in <= concat;

                    // remove old samples if we're more than halfway full
                    fifo_request_output <= (fifo_size >= SAMPLE_DEPTH / 2);

                    if(trigger) state <= `FILL;
                end

                `FILL : begin
                    // place samples into FIFO
                    fifo_input_ready <= 1;
                    fifo_data_in <= concat;

                    // don't pop anything out the FIFO
                    fifo_request_output <= 0;

                    if(fifo_size == SAMPLE_DEPTH - 1) state <= `DOWNLINK;
                end

                `DOWNLINK : begin
                    // place no samples into FIFO
                    fifo_input_ready <= 0;


                    case (downlink_fsm_state)
                        0 : begin
                            if (~fifo_empty) begin
                                fifo_request_output <= 1;
                                downlink_fsm_state <= 1;
                            end

                            else state <= `IDLE;
                        end

                        1 : begin
                            fifo_request_output <= 0;

                            if (fifo_output_valid) begin
                                tx_data <= fifo_data_out;
                                tx_start <= 1;
                                downlink_fsm_state <= 2;
                            end
                        end

                        2 : begin
                            tx_start <= 0;

                            if (~tx_busy && ~tx_start) downlink_fsm_state <= 0;
                        end
                    endcase

                end
            endcase
        end
    end

endmodule


`default_nettype wire