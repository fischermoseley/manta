{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#manta-a-configurable-and-approachable-tool-for-fpga-debugging-and-rapid-prototyping","title":"Manta: A Configurable and Approachable Tool for FPGA Debugging and Rapid Prototyping","text":"<p>Manta is a tool for moving data between a host machine and a FPGA over UART or Ethernet. It's primarily intended for debugging and rapid prototyping of FPGA designs, but it's robust enough to be used as a simple, reliable transport layer.</p> <p>Manta works by generating a number of cores that are instantiated in the FPGA design. These allow for a variety of functions, such as reading and writing to registers and memory, or capturing data with a logic analyzer. These cores are operated by the connected host machine through either the Manta CLI, or a simple Python API.</p> <p>Manta is written in Amaranth HDL, and the generated designs may be used natively in other Amaranth designs, or exported to vendor-agnostic Verilog-2001. All dependencies are cross-platform, so Manta can be used on any machine that has at least Python 3.8 or newer installed.</p> <p>Manta's capabilities are best reflected in its cores, for which a brief description of each is provided below:</p>"},{"location":"#logic-analyzer-core","title":"Logic Analyzer Core","text":"<p>More details available on the full documentation page.</p> <p>This core captures a timeseries of digital signals from within the FPGA, much like a benchtop logic analyzer would. This captures data on the FPGA's native clock and presents it as a waveform, making it very useful for debugging logic cycle-by-cycle. This concept is very similar to the Xilinx Integrated Logic Analyzer (ILA) and Intel SignalTap utilities.</p> <p>You may find this core useful for:</p> <ul> <li> <p>Verifying specification adherence for connected hardware - for instance, you're writing a S/PDIF decoder that works in simulation, but fails in hardware. The logic analyzer core can record a cycle-by-cycle capture of what's coming off the cable, letting you verify that your input signals are what you expect. Even better, Manta will let you play that capture back in your preferred simulator, letting you feed the exact same inputs to your module in simulation and check your logic.</p> </li> <li> <p>Capturing arbitrary data - you're working on a DSP project, and you'd like to grab some test data from your onboard ADCs to start prototyping your signal processing with. Manta will grab that data, and export it for you.</p> </li> </ul>"},{"location":"#io-core","title":"I/O Core","text":"<p>More details available on the full documentation page.</p> <p>This core presents a series of user-accessbile registers to the FPGA fabric, which may be configured as either inputs or outputs. The value of an input register can be read off the FPGA by the host machine, and the value of an output register on the FPGA may be set by the host machine. This is handy for getting small amounts of information into and out of the FPGA, debugging, configuration, or experimentation. This concept is very similar to the Xilinx Virtual IO and Intel In-System Sources and Probes tools.</p> <p>You may find this core useful for:</p> <ul> <li> <p>Prototyping designs in Python, and incrementally migrating them to hardware - you're working on some real-time signal processing, but you want to prototype it with some sample data in Numpy before meticulously implementing everything in Verilog.</p> </li> <li> <p>Making dashboards - you'd like to get some telemetry out of your existing FPGA design and display it nicely, but you don't want to implement an interface, design a packetization scheme, and write a library.</p> </li> </ul>"},{"location":"#memory-cores","title":"Memory Cores","text":"<p>More details available on the full documentation page.</p> <p>This core creates a two-port block memory on the FPGA, and gives one port to the host machine, and the other to your logic on the FPGA. The width and depth of this block memory is configurable, allowing large chunks of arbitrarily-sized data to be shuffled onto and off of the FPGA by the host machine, via the Python API. This lets you establish a transport layer between the host and FPGA, that treats the data as exactly how it exists on the FPGA.</p> <p>You may find this core useful for:</p> <ul> <li> <p>Moving data between a host and connected FPGA - you're working on a cool new machine learning accelerator, but you don't want to think about how to get training data and weights out of TensorFlow, and into your core.</p> </li> <li> <p>Hand-tuning ROMs - you're designing a digital filter for a DSP project and would like to tune it in real-time, or you're developing a soft processor and want to upload program code without rebuilding a bitstream.</p> </li> </ul>"},{"location":"#about","title":"About","text":"<p>Manta and its source code are released under a GPLv3 license, and it was originally developed as part of my Master's Thesis at MIT in 2023, done under the supervision of Dr. Joe Steinmeyer. The thesis itself is copyrighted by Fischer Moseley (me!), but feel free to use the following Bibtex if you'd like to cite it:</p> <pre><code>@misc{manta2023,\n    author={Fischer Moseley},\n    title={Manta: An In-Situ Debugging Tool for Programmable Hardware},\n    year={2023},\n    month={may}\n    howpublished={\\url{https://hdl.handle.net/1721.1/151223}}\n}\n</code></pre>"},{"location":"alternatives/","title":"Alternatives","text":"<p>There's quite a few FPGA debugging tools out there, and it may happen that your needs are better met by another tool! This section aims to provide a list of alternatives, in hopes that you're able to be confident in your debugging flow.</p>"},{"location":"alternatives/#open-source-tools","title":"Open Source Tools","text":""},{"location":"alternatives/#litescope","title":"LiteScope","text":"<p>An embedded logic analyzer written in Migen, primarily for use in LiteX SoC designs. Also includes IO peek and poke, as well as UART, Ethernet, and PCIe interfaces with a host machine. Includes VCD, Sigrok, CSV, and Python data export.</p> <ul> <li>Source Code</li> <li>Documentation</li> </ul>"},{"location":"alternatives/#gatemate-ila","title":"GateMate ILA","text":"<p>An embedded logic analyzer written in Verilog, targeting the GateMate FPGA family from Colonge Chip and the Yosys/NextPNR toolchain. Communication between the host and FPGA is accomplished with SPI, via a FT232 or FT2232 used as a USB-SPI adapter. GateMate is inteneded to be used with GTKWave, so the tool generates <code>.gtkw</code> files in addition to VCD files.</p> <ul> <li>Source Code</li> </ul>"},{"location":"alternatives/#zipcpu-debugger","title":"ZipCPU Debugger","text":"<p>A set of embedded debugging modules written by Dan Gisselquist of ZipCPU fame. Communication between the host and FPGA is accomplished with UART, and control of the debugger is performed with a C++ API on the host. A wishbone interface is provided on the FPGA side to connect to other Wishbone-based debugging tools that can provide control of user registers, block RAM, and an embedded logic analyzer. Supports dumping of signals to a VCD file.</p> <ul> <li>Source Code</li> <li>Documentation, under the How to Debug an FPGA section.</li> </ul>"},{"location":"alternatives/#commercial-tools","title":"Commercial Tools","text":""},{"location":"alternatives/#xilinx-integrated-logic-analzyer","title":"Xilinx Integrated Logic Analzyer","text":"<p>An embedded logic analyzer for Xilinx FPGAs, provided as part of the Xilinx Vivado development suite. Communication between the host and FPGA is accomplished with JTAG, typically running over a USB cable to the device. Includes an integrated waveform viewer, and VCD and CSV export. Also supports a JTAG-to-AXI mode, which integrates well with Xilinx IP, which uses primarily AXI. Also integrates with the ChipScoPy API, which allows for Python control of the ILA on Versal devices. The ILA was previously known as ChipScope in earlier versions of Vivado.</p> <ul> <li>ILA Documentation</li> <li>ILA User's Guide</li> <li>ChipScoPy API</li> </ul>"},{"location":"alternatives/#xilinx-virtual-io","title":"Xilinx Virtual IO","text":"<p>A tool for reading and writing to individual registers on the FPGA, provided as part of the Xilinx Vivado development suite. Just like the ILA, communication between the host and FPGA is done over JTAG. Control over the registers is done through the Vivado GUI or through the Tcl interpreter. In the case of Versal devices, the ChipScoPy API can also control the registers.</p> <ul> <li>Virtual IO Documentation</li> <li>ChipScoPy API</li> </ul>"},{"location":"alternatives/#intel-signal-tap","title":"Intel Signal Tap","text":"<p>An embedded logic analyzer for Intel/Altera FPGAs, provided as part of the Quartus development suite. Communication between the host and FPGA is accomplished with JTAG, and a programmable interface is provided via Tcl. Signal Tap is notable for providing a significant amount of configurability in the trigger conditions, and provides a small scripting language called Trigger Flow that allows users to define triggers as state machines. Signal Tap also allows for Simulation-Aware nodes, which allows for running simulations with data captured from the real world. At the time of writing, this feature is only available in the most recent and full-featured version of the Quartus suite, Quartus Prime Pro Edition 22.4.</p> <ul> <li>Documentation</li> </ul>"},{"location":"alternatives/#intel-in-system-sources-and-probes","title":"Intel In-System Sources and Probes","text":"<p>A tool for reading and writing to individual registers on the FPGA, provided for Intel/Altera FPGAs as part of the Quartus development suite. Just like Signal Tap, communication between the host and FPGA is accomplished with JTAG.</p> <ul> <li>Documentation</li> </ul>"},{"location":"alternatives/#lattice-reveal","title":"Lattice Reveal","text":"<p>An embedded logic analyzer for Lattice FPGAs, provided as part of the Diamond development suite. Communication between the host and FPGA is accomplished with JTAG. Reveal is notable for providing a significant amount of configurability in the trigger conditions, and supports trigger conditions formed with a mix of combinational and sequential logic. Reveal also provides special support for Wishbone buses, and for controlling SERDES modules on ECP5 devices.</p> <ul> <li>Documentation</li> </ul>"},{"location":"alternatives/#opal-kelly-frontpanel-sdk","title":"Opal Kelly FrontPanel SDK","text":"<p>Unlike other entries in this list, Opal Kelly's FrontPanel SDK is not marketed as a debugger (although it can be used as such). Instead, it's designed to provide a host computer with a real time interface to FPGA signals, and present them on a graphical \u201cfront panel\". These front panels exist as a GUI window on the host, and contain buttons, knobs, and indicators, much like a LabVIEW virtual instrument. Communication between the host and FPGA is accomplished with either USB or PCIe. Bindings for hosts running Windows, macOS, and Linux are provided, and target C, C++, C#, Python, Java, Ruby, and MATLAB. The FrontPanel SDK differs from other debuggers in that it provides a skeleton module into which the user logic is instantiated, instead of being instantiated inside the user's logic.</p> <ul> <li>Documentation</li> <li>User's Guide</li> </ul>"},{"location":"alternatives/#matlab-fpga-data-capture","title":"MATLAB FPGA Data Capture","text":"<p>An embedded logic analyzer for Xilinx and Altera FPGAs, provided as part of MATLAB. Communication between the host and FPGA is accomplished with JTAG, but Ethernet is supported for Xilinx FPGAs. Notably, this tool allows for data to be captured and used directly inside MATLAB, which also includes a framework for FPGA-in-the-loop testing. It also provides an AXI manager IP block that allows for reads and writes to an AXI memory map from MATLAB. This IP supports PCI Express on Xilinx FPGAs, in addition to JTAG and Ethernet.</p> <ul> <li>Documentation</li> </ul>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#system-architecture","title":"System Architecture","text":"<p>The whole system looks like the following:</p> <p></p> <p>Manta consists of two parts - a Python API running on a host machine, and an autogenerated block of RTL that's included with your logic on a FPGA. Either UART or Ethernet is used for communication, which allows the host machine to operate the debugging cores on the FPGA.</p>"},{"location":"architecture/#manta-architecture","title":"Manta Architecture","text":"<p>The logic Manta places on the FPGA consists of a series of cores connected in a chain along a common bus. Each core provides a unique method for interacting with the user\u2019s logic, which it connects to by routing signals (called probes) between the user\u2019s logic and the cores that interface with it.</p> <p></p> <p>These probes are presented as addressable memory, and are be controlled by reading and writing to their corresponding memory - not unlike registers on a microcontroller. Each core is allotted a section of address space at compile time, and operations addressed to a core\u2019s address space control the behavior of the core. These cores are then daisy-chained along an internal bus, which permits a chain arbitrarily many cores to be placed on the bus.</p> <p>At the beginning of this chain is a module called a receive bridge, which converts incoming UART/Ethernet communication from the host into read and write requests, which are placed on the bus. These are called bus transactions, and once placed on the bus, they travel through each core before reaching the transmit bridge at the end of the chain. This module places the result of the bus transaction back on the UART/Ethernet interface, and sends it back to the host. This produces a request-response style of communication between the host machine and the FPGA.</p>"},{"location":"architecture/#data-bus","title":"Data Bus","text":"<p>The data bus is designed for simplicity, and consists of five signals used to perform reads and writes on memory:</p> <ul> <li><code>addr [15:0]</code>, indicating the memory address targeted by the current transaction.</li> <li><code>data [15:0]</code>, which data is read from during a read, or written to during a write.</li> <li><code>rw</code>, indicating a read or write transaction if the signal is low or high respectively.</li> <li><code>valid</code>, which is driven high only when the operation specified by the other signals is to be executed.</li> </ul> <p>Each core has a bus input and output port, so that cores can be daisy-chained together. When it receives an incoming bus transaction (signalled by <code>valid</code>), the core checks the address on the wire against its own memory space. If the address lies within the core, the core will perform the requested operation against its own memory space. In the case of a read, it places the data at that address on <code>data</code>, and in the case of a write, it copies the value of <code>data</code> to the specified location in memory. However, if the address lies outside of the memory of the core, then no operations are performed.</p> <p> </p>"},{"location":"architecture/#message-format","title":"Message Format","text":"<p>Ethernet and UART both allow a stream of bytes to be sent between the host and FPGA, but since they're just interfaces, they don't define how these bytes are structured. As a result, Manta implements its own messaging format, with the following structure:</p> <p></p> <p>Each of these messages is a string of ASCII characters consisting of a preamble, optional address and data fields, and an End of Line (EOL). The preamble denotes the type of operation, R for a read and W for a write. The address and data fields are encoded as hexadecimal digits, represented with the characters 0-9 and A-F in ASCII. As a result, four characters are needed to encode a 16-bit address or 16-bits of data. If the message specifies a write request, then it will contain a data field after the address field. Both request types will conclude with an End of Line, which consists of the two ASCII characters indicating a Carriage Return (CR) and a Line Feed (LF).</p> <p>These requests are sent by the host machine to the FPGA, which reads them from the <code>rx</code> line on the interface transceiver. This is handled by the receive bridge, which parses incoming messages, and generates bus transactions from them. Once this transaction runs through every core in the chain, it arrives at the transmit bridge, which may send a response back to the host over the <code>tx</code> line.</p> <p>If the request specified a read operation, then a response will be produced. These responses have the same structure as the read request itself, albeit with the data read from memory substituted in place of the address. This results in a message of the same length, just with the address swapped for data. If the request specified a write operation, then no response will be sent back to the host. Manta provides no report of if the write was successful - if a write operation must be verified, Manta will just perform a read operation on the same address location and check the value.</p> <p>An example of some bus traffic is provided below:</p> Sequence Number Interface Activity Operation 1 Host \u2192 FPGA: R1234(CR)(LF) - 2 FPGA \u2192 Host: R5678(CR)(LF) Read 0x5678 from 0x1234 3 Host \u2192 FPGA: WF00DBEEF(CR)(LF) Write 0xBEEF to 0xF00D 4 Host \u2192 FPGA: RF00D(CR)(LF) - 5 FPGA \u2192 Host: RBEEF(CR)(LF) Read 0xBEEF from 0xF00D 6 Host \u2192 FPGA: W12340000(CR)(LF) Write 0x0000 to 0x1234 <p>When UART is used, these bytes are transmitted directly across the wire, but when Ethernet is used, they're packed into the packet's payload field.</p>"},{"location":"architecture/#cores","title":"Cores","text":""},{"location":"architecture/#io-core","title":"IO Core","text":"<p>This is done with the architecture shown below:</p> <p></p> <p>Each of the probes is mapped to a register of Manta's internal memory. Since Manta's internal registers are 16 bits wide, probes less than 16 bits are mapped to a single register, but probes wider than 16 bits require multiple.</p> <p>Whatever the number of registers required, these are read from and written to by the host machine - but the connection to the user's logic isn't direct. The value of each probe is buffered, and only once the <code>strobe</code> register has been set to one will the buffers update. When this happens, output probes provide new values to user logic, and new values for input probes are read from user logic. This provides a convenient place to perform clock domain crossing, and also mitigates the possibility of an inconsistent system state. This is explained in more detail in Chapter 3.6 of the original thesis.</p>"},{"location":"architecture/#logic-analyzer","title":"Logic Analyzer","text":"<p>The Logic Analyzer Core's implementation on the FPGA consists of three primary components:</p> <p></p> <ul> <li>The Finite State Machine (FSM), which controls the operation of the core. The FSM's operation is driven by its associated registers, which are placed in a separate module. This permits simple CDC between the bus and user clock domains.</li> <li>The Trigger Block, which generates the core's trigger condition. The trigger block contains a trigger for each input probe, and the registers necessary to configure them. It also contains the \\(N\\)-logic gate (either AND or OR) that generates the core's trigger from the individual probe triggers. CDC is performed in exactly the same manner as the FSM. If an external trigger is specified, the trigger block is omitted from the Logic Analyzer Core, and the external trigger is routed to the FSM's <code>trig</code> input.</li> <li>The Sample Memory, which stores the states of the probes during a capture. This is implemented as a dual-port, dual-clock block memory, with the bus on one port and the probes on the other. The probe-connected port only writes to the memory, with the address and enable pins managed by the FSM. CDC is performed in the block RAM primitive itself.</li> </ul>"},{"location":"architecture/#memory-core","title":"Memory Core","text":"<p>Each Memory core is actually a set of 16-bit wide BRAMs with their ports concatenated together, with any spare bits masked off. Here's a diagram:</p> <p></p> <p>Since each \\(n\\)-bit wide block memory is actually \\(ceil(n/16)\\) BRAMs under the hood, addressing the BRAMs correctly from Manta's internal bus is important. BRAMs are organized such that each 16-bit slice of a \\(N\\)-bit word in the Block Memory core are placed next to each other in bus address space. For instance, a 34-bit wide block memory would exist on Manta's internal bus as:</p> Bus Address Space BRAM Address Space BASE_ADDR + 0 address 0, bits 0-15 BASE_ADDR + 1 address 1, bits 0-15 BASE_ADDR + n address n, bits 0-15 ... ... BASE_ADDR + 0 + DEPTH address 0, bits 16-31 BASE_ADDR + 1 + DEPTH address 1, bits 16-31 BASE_ADDR + n + DEPTH address n, bits 16-31 ... ... BASE_ADDR + 0 + (2 * DEPTH) address 0, bits 32-33 BASE_ADDR + 1 + (2 * DEPTH) address 1, bits 32-33 BASE_ADDR + n + (2 * DEPTH) address n, bits 32-33 ... ... <p>...and so on.</p>"},{"location":"ethernet_interface/","title":"Ethernet Interface","text":""},{"location":"ethernet_interface/#overview","title":"Overview","text":"<p>For scenarios where UART is not available or higher bandwidth is desired, Manta provides an Ethernet interface for communicating between the host and FPGA. This interface uses UDP for communication, and leverages the builtin Python <code>sockets</code> module on the host side, and the open-source LiteEth Ethernet core on the FPGA side.</p> <p>Not every device is supported!</p> <p>Although Manta aims to be as platform-agnostic as possible, Ethernet PHYs and FPGA clock primitives are very particular devices. As a result, the supported devices are loosely restricted to those on this list. If a device you'd like to use isn't on the list, the community would love your help!</p> <p>Although UDP does not guarantee reliable packet delivery, this usually doesn't pose an issue in practice. Manta will throw a runtime error if packets are dropped, and the UDP checksum and Ethernet FCS guarantee that any data delivered is not corrupted. Together, these two behaviors prevent corrupted data from being provided to the user, as Manta will error before returning invalid data. As long as your network is not terribly congested, Manta will operate without issue.</p>"},{"location":"ethernet_interface/#configuration","title":"Configuration","text":"<p>The configuration of the Ethernet core is best shown by example: <pre><code>ethernet:\n  phy: LiteEthPHYRMII\n  vendor: xilinx\n  toolchain: vivado\n\n  clk_freq: 50e6\n  refclk_freq: 50e6\n\n  fpga_ip_addr: \"192.168.0.110\"\n  host_ip_addr: \"192.168.0.100\"\n</code></pre> This snippet at the end of the configuration file defines the interface. The following parameters must be set:</p> <ul> <li> <p><code>phy</code> (required): The name of the LiteEth PHY class to use. Valid values consist of any of the names in this list. Select the appropriate one for your FPGA vendor and family.</p> </li> <li> <p><code>vendor</code> (required): The vendor of the FPGA being designed for. Currently only values of <code>xilinx</code> and <code>lattice</code> are supported. Used to generate timing constraints files, which are currently unused.</p> </li> <li> <p><code>toolchain</code> (required): The toolchain being used. Currently only values of <code>vivado</code> and <code>diamond</code> are supported.</p> </li> <li> <p><code>clk_freq</code> (required): The frequency of the clock provided to the Manta instance.</p> </li> <li> <p><code>refclk_freq</code> (required): The frequency of the reference clock to be provided to the Ethernet PHY. This frequency must match the MII variant supported by the PHY, as well as speed that the PHY is being operated at. For instance, a RGMII PHY may be operated at either 125MHz in Gigabit mode, or 25MHz in 100Mbps mode.</p> </li> <li> <p><code>fpga_ip_addr</code> (required): The IP address the FPGA will attempt to claim. Upon power-on, the FPGA will issue a DHCP request for this IP address. The easiest way to check if this was successful is by pinging the FPGA's IP, but if you have access to your network's router it may report a list of connected devices.</p> </li> <li> <p><code>host_ip_addr</code> (required): The IP address of the host machine, which the FPGA will send packets back to.</p> </li> </ul> <p>Lastly, any additonal arguments provided in the <code>ethernet</code> section of the config file will be passed to the LiteEth standalone core generator. As a result, the examples provided by LiteEth may be of some service to you if you're bringing up a different FPGA!</p> <p>LiteEth doesn't always generate its own <code>refclk</code>!</p> <p>Although LitEth is built on Migen and LiteX which support PLLs and other clock generation primitives, I haven't seen it instantiate one to synthesize a suitable <code>refclk</code> at the appropriate frequency from the input clock. As a result, for now it's recommended to generate your <code>refclk</code> outside Manta, and then use it to clock your Manta instance.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#overview","title":"Overview","text":"<p>To use Manta, you'll need a host machine with a FPGA board connected over UART, or a FPGA board connected to the same network via Ethernet. You'll then:</p> <ul> <li>Specify a set of debug cores you wish to include in your design. This is done by writing a configuration file, typically called <code>manta.yaml</code>. Specifying files in JSON is also supported, as long as the hierarchy in the file is equivalent. Just make sure that your YAML files end in <code>.yaml</code> or <code>.yml</code>, and that JSON files end in <code>.json</code>.</li> <li>Invoke Manta to generate Verilog from the configuration provided. This is done by running <code>manta gen [config_file] [verilog_file]</code> at the command line, which generates a Verilog file (typically named <code>manta.v</code>) from the provided configuration file. This Verilog file contains a definition for a Verilog module named <code>manta</code>, and all its constituent modules.</li> <li>Instantiate <code>manta</code> in your design, and connecting it to the logic you'd like to debug. Manta will provide an example instantiation if you run <code>manta inst [config_file]</code>, which you can copy-paste into your source code. You'll connect its ports to the logic you're trying to debug, as well as to whatever interface you're using to communicate with the host. This will be a serial transciever on your development board if you're using UART, or it's RMII PHY if you're using Ethernet.</li> <li>Build and upload the design to your FPGA using your preferred toolchain.</li> <li>Use the debug core(s) through the Python API or the command line. The functions availble to each core are described in their documentation.</li> <li>Repeat! As you debug, you'll probably want to change exactly how Manta is configured. This means tweaking the configuration file, regenerating the Verilog module, and so on.</li> </ul>"},{"location":"getting_started/#example-configuration","title":"Example Configuration","text":"<p>An example config file is provided below. If this file was named <code>manta.yaml</code> then running <code>manta gen manta.yaml manta.v</code> would generate Verilog for a <code>manta</code> module that matched the config file.</p> <pre><code>---\ncores:\n  my_io_core:\n    type: io\n\n    inputs:\n      probe_0_in: 6\n      probe_1_in: 12\n\n    outputs:\n      probe_2_out: 20\n      probe_3_out: 1\n\n  my_logic_analyzer:\n    type: logic_analyzer\n    sample_depth: 4096\n    trigger_location: 1000\n\n    probes:\n      larry: 1\n      curly: 3\n      moe: 9\n\n    triggers:\n      - moe RISING\n      - curly FALLING\n\nuart:\n  port: \"auto\"\n  baudrate: 3000000\n  clock_freq: 100000000\n</code></pre> <p>Although it's just an example, this config file shows the two things every Manta configuration needs, namely:</p> <ul> <li> <p>Cores: A list of the debug cores Manta should place on your FPGA. The behavior and configuration of the cores is described in more detail on their documentation pages, but this list contains each core you'd like included in your <code>manta</code> module. This list can have as many entires as your FPGA can support, so long as Manta can address them all. If it can't, it'll throw an error when it tries to generate Verilog.</p> </li> <li> <p>Interface: The way data gets on and off the FPGA. At present, Manta only supports UART and Ethernet interfaces. These are described in more detail on their documentation pages, but the interface of choice is specified with either a <code>uart</code> or <code>ethernet</code> at the end of the configuration file.</p> </li> </ul> <p>This Manta instance has an IO Core and a Logic Analyzer, each containing a number of probes at variable widths. The Manta module itself is provided a 100MHz clock, and communicates with the host over UART running at 3Mbaud. This is just an example, and more details are available in the documentation page for each core.</p>"},{"location":"getting_started/#example-instantiation","title":"Example Instantiation","text":"<p>Lastly, we Manta can automatically generate a copy-pasteable Verilog snippet to instantiate Manta in your design by running <code>manta inst [config_file]</code>. For example, the following snippet is generated for the configuration above:</p> <p>Reset is active high!</p> <p>The Manta instance will reset while <code>rst</code> is held high. If you want to share reset logic with an active low reset signal (for example, <code>rst_n</code>), be sure to invert it first.</p> <pre><code>manta manta_inst (\n    .clk(clk),\n    .rst(rst),\n    .rx(rx),\n    .tx(tx),\n    .probe_0_in(probe_0_in),\n    .probe_1_in(probe_1_in),\n    .probe_2_out(probe_2_out),\n    .probe_3_out(probe_3_out),\n    .larry(larry),\n    .curly(curly),\n    .moe(moe));\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>Before installing, make sure to upgrade your <code>pip</code> to the latest version:</p> <pre><code>pip install --upgrade pip\n</code></pre>"},{"location":"installation/#latest-version","title":"Latest Version","text":"<p>You can install the latest version of Manta directly from source with:</p> <pre><code>pip install --upgrade git+https://github.com/fischermoseley/manta.git\n</code></pre>"},{"location":"installation/#editable-development-install","title":"Editable Development Install","text":"<p>If you're working on the source, you might want an editable installation with some extra dependencies used for development:</p> <pre><code>git clone https://github.com/fischermoseley/manta.git\ncd manta\npip install -e \".[dev]\"\n</code></pre> <p>Manta's hardware-in-the-loop tests rely on Amaranth's build system for programming FPGAs, which in turn rely on the open-source <code>xc3sprog</code> and <code>iceprog</code> tools for programming Xilinx and ice40 devices, respecitvely. If you'd like to run these tests locally, you may need to install these tools and have them available on your <code>PATH</code>. If you're on Linux, you may also need to add a new udev rule to give non-superuser accounts access to any connected FTDI devices. This can be done by making a new file at <code>/etc/udev/rules.d/99-ftdi-devices.rules</code>, which contains:</p> <pre><code>ACTION==\"add\", ATTR{idVendor}==\"0403\", ATTR{idProduct}==\"6010\", MODE:=\"666\"\n</code></pre> <p>Be sure to reload your udev rules after saving the file.</p>"},{"location":"installation/#adding-manta-to-path-recommended","title":"Adding Manta to Path (Recommended)","text":"<p>It's recommended to place Manta on your system path by adding <code>export PATH=\"~/.local/bin:$PATH\"</code> to your <code>.bashrc</code> or <code>.zshrc</code>. This isn't strictly necessary, but it means that Manta (and any other executable Python modules) can be run as just <code>manta</code> on the command line, instead of <code>python3 -m manta</code>. If you're on Windows, this location will likely be different.</p> <p>Later Manta will be availabe on the PyPI lists, and you'll be able to just <code>pip install mantaray</code>, but that's not configured quite yet.</p>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>Manta requires the following dependencies:</p> <ul> <li>Amaranth HDL, which comes with it's own built-in copy of Yosys.</li> <li>LiteEth, for sending and receiving UDP packets on the FPGA.</li> <li>pySerial, for communicating with the FPGA over UART.</li> <li>pyYAML, for parsing configuration files written in YAML.</li> <li>pyVCD, for writing waveforms captured by the Logic Analyzer Core to standard Value Change Dump (VCD) files.</li> </ul> <p>As well as these dependencies for development, which are installed with the <code>[dev]</code> argument:</p> <ul> <li>Pytest, for unit testing.</li> <li>Black, for formatting the Python source.</li> <li>mkdocs-material, for generating the documentation site.</li> <li>amaranth_boards, for building designs for hardware-in-the-loop testing done by the CI.</li> </ul>"},{"location":"io_core/","title":"IO Core","text":""},{"location":"io_core/#overview","title":"Overview","text":"<p>Registers are a fundamental building block of digital hardware, and the IO core provides a simple way of interacting with them from the host machine. It allows you to define a set of inputs and outputs of arbitrary width, and then set values to the outputs and read values from the inputs.</p> <p>This is a very, very simple task - and while configuration is straightforward, there are a few caveats. More on both topics below:</p>"},{"location":"io_core/#configuration","title":"Configuration","text":"<p>Just like the rest of the cores, the IO core is configured via an entry in a project's configuration file. This is easiest to show by example:</p> <p><pre><code>---\nmy_io_core:\n  type: io\n\n  inputs:\n    kermit: 3\n    piggy: 1\n    animal: 38\n    scooter:\n      width: 4\n      initial_value: 13\n\n  outputs:\n    fozzy: 1\n    gonzo: 3\n\n  user_clock: True\n</code></pre> Inside this configuration, the following parameters may be configured:</p> <ul> <li><code>name</code> (required): The name of the IO core. This name is used to reference the core when working with the API, and can be whatever you'd like.</li> <li><code>type</code> (required): This denotes that this is an IO core. All cores contain a <code>type</code> field, which must be set to <code>io</code> to be recognized as an IO core.</li> <li><code>inputs</code> (optional): This lists all inputs from from the FPGA fabric to the host machine. Signals in this list may be read by the host, but cannot be written to. Technically specifying input probes is totally optional - it's perfectly fine to have an IO core with only output probes.</li> <li><code>outputs</code> (optional): This lists all outputs from the host machine to the FPGA fabric. Signals in this list are usually written to by the host, but they can also be read from. Doing so returns the value last written to the register. Just like the <code>inputs</code> parameter, this list is technically optional, and it's perfectly valid to have an IO core with input probes only.<ul> <li><code>initial_value</code> (optional): This sets an initial value for an output probe to take after the FPGA powers on. This is done with an <code>initial</code> statement in Manta's Verilog, and is independent of the input clock or resets elsewhere in the FPGA. This parameter is optional, and if it isn't provided the probe will initialize to zero.</li> </ul> </li> <li><code>user_clock</code> (optional): If set to True, an extra input port will be added to the <code>manta</code> module for an clock input to run the IO core on. This lets the IO Core handle clock domain crossing through its internal buffers. If set to False, Manta will run the IO core from its internal clock (the one provided through <code>manta</code>'s <code>clk</code> port). More information on this is available in the diagram below. This parameter is optional, and defaults to False.</li> </ul> <p>Name things carefully!</p> <p>The names of the core and its probes are referenced in the autogenerated Verilog. This means that while the names can be arbitrary, they must be unique within your project and not contain any characters that your synthesis engine won't appreciate.</p>"},{"location":"io_core/#python-api","title":"Python API","text":"<p>The IO core functionality is stored in the <code>Manta.IOCore</code> class in src/manta/io_core/__init__.py, and it may be controlled with the two functions:</p> <p><code>Manta.IOCore.set_probe(name, data)</code></p> <ul> <li>[<code>string</code>] name: The probe to write to. Must not be an output port, and must match the name provided in the config file.</li> <li>[<code>int</code>, <code>bool</code>] data: The value to write to an output probe. May be signed or unsigned, but will raise an exception if the value is too large for the width of the port.</li> <li>returns: None</li> </ul> <p>This method is blocking. When called it will dispatch a request to the FPGA, and halt execution until the request has been sent.</p> <p><code>Manta.IOCore.get_probe(name)</code></p> <ul> <li>[<code>string</code>] name: The probe to read from. May be either an input or an output port, and must match the name provided in the config file.</li> <li>returns: The value of an input or output probe. In the case of an output probe, the value returned will be the last value written to the probe.</li> </ul> <p>This method is blocking. When called it will dispatch a request to the FPGA, and halt execution until the request has been sent and a response has been received.</p>"},{"location":"io_core/#example","title":"Example","text":"<p>A small example is shown below, using the example configuration above. More extensive examples can also be found in the repository's examples/ folder.</p> <pre><code>&gt;&gt;&gt; import Manta\n&gt;&gt;&gt; m = Manta\n&gt;&gt;&gt; m.my_io_core.set_probe(\"fozzy\", True)\n&gt;&gt;&gt; m.my_io_core.get_probe(\"fozzy\")\nTrue\n&gt;&gt;&gt; m.my_io_core.set_probe(\"gonzo\", 4)\n&gt;&gt;&gt; m.my_io_core.get_probe(\"scooter\")\n5\n</code></pre>"},{"location":"io_core/#limitations","title":"Limitations","text":"<p>While the IO core performs a very, very simple task, it carries a few caveats.</p> <ul> <li> <p>First, it's not instantaneous. Manta has designed to be as fast as possible, but setting and querying registers relies on passing messages between the host and FPGA, which is slow relative to FPGA clock speeds! If you're trying to set values in your design with cycle-accurate timing, this will not do that for you. However, the Logic Analyzer's playback feature might be helpful.</p> </li> <li> <p>Second, the API methods are blocking, and will wait for a response from the FPGA before resuming program execution. Depending on your application, you might want to run your IO Core operations in a separate thread, but you can also decrease the execution time by using a faster interface between the host and FPGA. This means using a higher UART baudrate, or using Ethernet.</p> </li> </ul>"},{"location":"logic_analyzer_core/","title":"Logic Analyzer Core","text":""},{"location":"logic_analyzer_core/#overview","title":"Overview","text":"<p>The Logic Analyzer core allows for debugging logic by capturing a set of digital signals to memory. This is done in response to a trigger condition, which starts the capture, which continues until the onboard memory is full, and the resulting capture is then read out to the user.</p> <p>While this is pretty much identical to the behavior of a benchtop logic analyzer, Manta has a few tricks up its sleeve that you may find useful! These are described below:</p>"},{"location":"logic_analyzer_core/#configuration","title":"Configuration","text":"<p>Just like the rest of the cores, the Logic Analyzer core is configured via an entry in a project's configuration file. This is easiest to show by example:</p> <pre><code>---\ncores:\n  my_logic_analyzer:\n    type: logic_analyzer\n    sample_depth: 4096\n    trigger_location: 1000\n\n    probes:\n      larry: 1\n      curly: 3\n      moe: 9\n\n    triggers:\n      - moe RISING\n      - curly FALLING\n</code></pre> <p>There's a few parameters that get configured here, including:</p> <ul> <li><code>name</code>: The name of the Logic Analyzer core. This name is used to reference the core when working with the API, and can be whatever you'd like.</li> <li><code>type</code>: This denotes that this is a Logic Analyzer core. All cores contain a <code>type</code> field, which must be set to <code>logic_analyzer</code> to be recognized as an Logic Analyzer core.</li> </ul>"},{"location":"logic_analyzer_core/#sample-depth","title":"Sample Depth","text":"<p>This refers to the number of samples saved in the capture, and is set with the <code>sample_depth</code> entry in the config file. A larger sample depth will use more resources, but show what your probes are doing over a longer time.</p>"},{"location":"logic_analyzer_core/#probes","title":"Probes","text":"<p>Probes are the signals in your logic that the Logic Analyzer connects to, and are specified in the <code>probes</code> entry of the config file. Each probe requires both a name and a width to be specified. These names can be whatever you'd like, however they are referenced in the autogenerated Verilog - so don't use something your synthesis engine won't appreciate.</p>"},{"location":"logic_analyzer_core/#triggers","title":"Triggers","text":"<p>Triggers are the conditions that your logic must meet in order to start a capture, and they're specified under the <code>triggers</code> entry in the config file. Manta's triggers are reprogrammable, meaning you don't need to rebuild your source code to change the trigger condition - just updating the configuration file is enough. If multiple triggers are provided, any one trigger being met will trigger the entire core.</p> <p>Each individual trigger is specified with the following structure:</p> <p><code>[probe]</code> <code>[operation]</code> <code>[argument]</code></p> <ul> <li> <p>probe: The probe that the trigger applies to. Each probe only supports one trigger on it. For instance, in the example above we couldn't add a trigger for <code>curly LEQ 4</code>, since we've already assigned a trigger to <code>curly</code>.</p> </li> <li> <p>operation: The logical operation to perform. Manta supports the following operations:</p> <ul> <li><code>RISING</code>, which checks if the probe has increased in value since the last clock cycle.</li> <li><code>FALLING</code>, which checks if the probe has decreased in value since the last clock cycle.</li> <li><code>CHANGING</code>, which checks if the probe is changed in value since the last clock cycle.</li> </ul> <p>These operations only compare a probe's value with itself, but sometimes it is useful to compare a probe's value to a constant. Manta provides a operations for doing such, including:</p> <ul> <li><code>GT</code>,  for greater than.</li> <li><code>LT</code>,  for less than.</li> <li><code>GEQ</code>, for greater than or equal to.</li> <li><code>LEQ</code>, for less than or equal to.</li> <li><code>EQ</code>, for equal to.</li> <li><code>NEQ</code>, for not equal to.</li> </ul> <p>These operations require a constant to compare against, referred to as an argument, which is described below:</p> </li> <li> <p>argument: A constant to compare against, if the operation specified requires one. On the FPGA, the argument will have just as many bits as the probe width.</p> </li> </ul> <p>Lastly, if you're not able to express your desired trigger condition in terms of the operators above, fear not! You can also specify an <code>external_trigger: true</code> entry in the config file, which exposes an input on Manta's top level for your own trigger.</p>"},{"location":"logic_analyzer_core/#trigger-position-optional","title":"Trigger Position (optional)","text":"<p>Sometimes, you care more about what happens before a trigger is met than afterwards, or vice versa. To accommodate this, the logic analyzer has an optional Trigger Position parameter, which sets when probe data is captured relative to the trigger condition being met. This is specified with the <code>trigger_position</code> entry in the configuration file, which sets how many samples to save prior to the trigger condition occurring. This is similar to a \"holdoff\" option on a traditional oscilloscope or logic analyzer.</p> <p>If <code>trigger_position</code> is not specified, Manta will default to centering the capture window around the trigger condition. This results in just as many samples before the trigger as after.</p>"},{"location":"logic_analyzer_core/#capture-modes-optional","title":"Capture Modes (optional)","text":"<p>The logic analyzer has a few different ways of capturing data, which are represented by the capture modes below:</p> <ul> <li>Single-Shot: Once the trigger condition is met, record the value of the probes on every clock cycle in a continuous single shot.</li> <li>Incremental: Record samples when the trigger condition is met, but don't record the samples when the trigger condition is not met. This is super useful for applications like audio processing or memory controllers, where there are many system clock cycles between signals of interest.</li> <li>Immediate: Record the value of the probes on every clock cycle, beginning immediately, and regardless of if the trigger condition is met. This is useful for investigating cases where a trigger condition is never being met (such as latchup or deadlock conditions) or obtaining a random snapshot of the FPGA's state.</li> </ul> <p>Most logic analyzers use a single-shot capture by default, so Manta will do the same if no <code>capture_mode</code> entry is provided in the project's configuration file.</p>"},{"location":"logic_analyzer_core/#usage","title":"Usage","text":""},{"location":"logic_analyzer_core/#capturing-data","title":"Capturing Data","text":"<p>Once you have your Logic Analyzer core on the FPGA, you can capture data with:</p> <p><pre><code>manta capture [config file] [LA core] [output filename] [[additional output filenames]...]\n</code></pre> The capture may be exported as either a VCD or CSV file. If <code>manta.yaml</code> contained the configuration at the top of this page, then the following would export a .vcd file containing the captured waveform:</p> <pre><code>manta capture manta.yaml my_logic_analyzer capture.vcd\n</code></pre> <p>This will reset your logic analyzer, configure it with the triggers specified in <code>manta.yaml</code>, perform a capture, and create the file. Additional output files may be passed as well - Manta will detect the file format based on the extension (<code>.vcd</code>, <code>.csv</code>). Verilog (<code>.v</code>) files are also supported, and will follow the playback mechanism described below.</p>"},{"location":"logic_analyzer_core/#playback","title":"Playback","text":"<p>Manta has the ability to generate a module that plays back a set of data captured from a Logic Analyzer core. This module has a set of outputs matching the inputs of the Logic Analyzer, which when enabled, will take the exact values captured by the logic analyzer. This module is synthesizable, and can either be used in simulation or included in the FPGA design.</p> <p>If the file <code>manta.yaml</code> contained the configuration above, then running: <pre><code>manta capture manta.yaml my_logic_analyzer capture.v\n</code></pre></p> <p>Generates a Verilog module at <code>capture.v</code> which can then be instantiated in the testbench or FPGA design in which it is needed.</p> <p>This is useful for two situations in particular:</p> <ul> <li> <p>Input Verification. Designs will often work in simulation, but fail in hardware. In the absence of any build errors, this usually means that the inputs being applied to the logic in simulation don't accurately represent those being applied to the logic in the real world. Playing signals back in simulation allows for easy comparison between simulated and measured input, and provides a nice way to check that the logic downstream is behaves properly.</p> </li> <li> <p>Sparse Sampling. Sometimes designs will have a small number of inputs, but a huge amount of internal state. In situations like these, it may be more efficient to sample the inputs and simulate the logic, instead of directly sampling the state. For instance, debugging a misbehaving branch predictor in a CPU can be done by recording activity on the address and data busses and playing them back in simulation - which would use less FPGA resources than sampling the entire pattern history table.</p> </li> </ul>"},{"location":"logic_analyzer_core/#python-api","title":"Python API","text":"<p>The Logic Analyzer core functionality is stored in the <code>Manta.LogicAnalyzerCore</code> class in src/manta/logic_analyzer/__init__.py. This class contains methods for capturing data, exporting it as <code>.vcd</code>, <code>.v</code> or <code>.csv</code> files, or as a Python list.</p>"},{"location":"memory_core/","title":"Memory Core","text":""},{"location":"memory_core/#overview","title":"Overview","text":"<p>Memory is the de facto means of storing data on FPGAs when the space needed exceeds a few registers. As a result, Manta provides a Memory core, which instantiates a dual-port RAM on the FPGA. One port is provided to the host, and the other is connected to your logic with the standard RAM interface (<code>addr</code>, <code>data_in</code>, <code>data_out</code>, <code>write_enable</code>). This allows the host to provide reasonably large amounts of data to user logic - or the other way around, or a mix of both!</p> <p>This is a very, very simple task - and while configuration is straightforward, there are a few caveats. More on both topics below:</p>"},{"location":"memory_core/#configuration","title":"Configuration","text":"<p>Just like the rest of the cores, the Memory core is configured via an entry in a project's configuration file. This is easiest to show by example:</p> <pre><code>---\ncores:\n  my_memory:\n    type: memory\n    mode: bidirectional\n    width: 12\n    depth: 16384\n</code></pre> <p>There's a few parameters that get configured here, including:</p> <ul> <li><code>name</code>: The name of the Memory core. This name is used to reference the core when working with the API, and can be whatever you'd like.</li> <li><code>type</code>: This denotes that this is a Memory core. All cores contain a <code>type</code> field, which must be set to <code>memory</code> to be recognized as an Memory core.</li> <li><code>mode</code>: The mode for the Memory core to operate in. This must be one of <code>bidirectional</code>, <code>host_to_fpga</code>, or <code>fpga_to_host</code>. Bidirectional memories can be both read or written to by the host and FPGA, but they require the use of a True Dual Port RAM, which is not available on all platforms (most notably, the ice40). Host-to-fpga and fpga-to-host RAMs only require a Simple Dual Port RAM, which is available on nearly all platforms.</li> <li><code>width</code>: The width of the Memory core, in bits.</li> <li><code>depth</code>: The depth of the Memory core, in entries.</li> </ul> <p>Manta won't impose any limit on the width or depth of the memory you instantiate, but since Manta instantiates BRAM primitives on the FPGA, you will be limited by what your FPGA can support. It helps to know your particular FPGA's architecture here.</p>"},{"location":"memory_core/#on-chip-implementation","title":"On-Chip Implementation","text":"<p>For most use cases, Manta will choose to implement the memory in Block RAM, if it is available on the device. However, the Verilog produced by Manta may be inferred to a number of memory types, including FF RAM or LUT (Distributed) RAM. For more information on how this is chosen, please refer to the Yosys documentation.</p>"},{"location":"memory_core/#python-api","title":"Python API","text":"<p>The Memory core functionality is stored in the <code>Manta.MemoryCore</code> classes in src/manta/memory_core.py, and it may be controlled with the two functions:</p> <p>Just like with the other cores, interfacing with the Memory with the Python API is simple:</p> <pre><code>from manta import Manta\nm = manta('manta.yaml')\n\nm.my_memory.write(addr=38, data=600)\nm.my_memory.write(addr=0x1234, data = 0b100011101011)\nm.my_memory.write(0x0612, 0x2001)\n\nfoo = m.my_memory.write(addr=38)\nfoo = m.my_memory.write(addr=1234)\nfoo = m.my_memory.write(0x0612)\n</code></pre> <p>Reading/writing in batches is also supported. This is recommended where possible, as reads are massively sped up by performing them in bulk:</p> <pre><code>addrs = list(range(0, 1234))\ndatas = list(range(1234, 2468))\nm.my_memory.write(addrs, datas)\n\nfoo = m.my_memory.read(addrs)\n</code></pre>"},{"location":"memory_core/#synchronicity","title":"Synchronicity","text":"<p>Since Manta's data bus is only 16-bits wide, it's only possible to manipulate the Memory core in 16-bit increments. This means that if you have a RAM that's \u226416 bits wide, you'll only need to issue a single bus transaction to read/write one entry in the RAM. However, if you have a RAM that's \u226516 bits wide, you'll need to issue a bus transaction to update each 16-bit slice of it. For instance, updating a single entry in a 33-bit wide RAM would require sending 3 messages to the FPGA: one for bits 1-16, another for bits 17-32, and one for bit 33. If your application expects each RAM entry to update instantaneously, this could be problematic.</p> <p>There's a few different ways to solve this - you could use an IO core to signal when a RAM's contents or valid - or you could ping-pong between two RAMs while one is being modified. The choice is yours, and Manta makes no attempt to prescribe any particular approach.</p> <p>Lastly, the interface you use (and to a lesser extent, your operating system) will determine the space between bus transactions. For instance, 100Mbit Ethernet is a thousand times faster than 115200bps UART, so the time where the RAM is invalid is a thousand times smaller.</p>"},{"location":"repository_structure/","title":"Repository Structure","text":""},{"location":"repository_structure/#repository-structure","title":"Repository Structure","text":"<ul> <li><code>src/manta/</code> contains the Python source needed to generate and run the cores.</li> <li><code>test/</code> contains Manta's tests, which are a mix of functional simulations and hardware-in-the-loop testing. These tests leverage the <code>pytest</code> testing framework.</li> <li><code>doc/</code> contains the documentation you're reading right now!</li> <li><code>examples/</code> contains examples of Manta being used in designs for a handful of FPGA boards.</li> <li><code>.github/</code> contains GitHub Actions workflows for automatically running the tests and building the documentation site on every commit.</li> </ul>"},{"location":"repository_structure/#tools-used","title":"Tools Used","text":"<ul> <li>The YosysHQ tools and Vivado are used for building bitstreams.</li> <li>draw.io is used for block diagrams.</li> <li>GitHub Pages is used to serve the documentation site, which is built with Material for MkDocs.</li> <li>GitHub Actions is used for continuous integration.</li> </ul>"},{"location":"repository_structure/#github-actions-setup","title":"GitHub Actions Setup","text":"<p>Since Vivado is large and requires individual licenses, it is run on a private server, which is configured as a self-hosted runner in GitHub Actions. This is a virtual server hosted with KVM/QEMU and managed by libvirt, which is configured as transient so that it reloads its state from a snapshot periodically. A Nexys4 DDR and Icestick are connected to the physical machine and passthrough-ed to this VM so that continuous integration can check against real hardware.</p>"},{"location":"uart_interface/","title":"UART Interface","text":""},{"location":"uart_interface/#overview","title":"Overview","text":"<p>Manta needs an interface to pass data between the host machine and FPGA, and UART is a convenient option. When configured to use UART, Manta will shuffle data back and forth using generic 8N1 serial with no flow control. This happens through a series of read and write transactions, which are specified using a messaging format described here.</p>"},{"location":"uart_interface/#configuration","title":"Configuration","text":"<p>The configuration of the UART interface is best shown by example:</p> <p><pre><code>uart:\n  port: \"auto\"\n  baudrate: 3000000\n  clock_freq: 100000000\n</code></pre> This snippet at the end of the configuration file defines the interface. The following parameters must be set:</p> <ul> <li> <p><code>port</code> (required): The name of the serial port on the host machine that's connected to the FPGA. Depending on your platform, this could be <code>/dev/ttyUSBXX</code>, <code>/dev/tty.usbserialXXX</code>, or <code>COMX</code>. If set to <code>auto</code>, then Manta will try to find the right serial port by looking for a USB device with the same VID and PID as a FT2232 - a USB/UART converter chip that's super popular on FPGA dev boards. This doesn't always work, but it's super convenient when it does. If your port isn't automatically detected, then just specify the port manually.</p> </li> <li> <p><code>baudrate</code> (required): The baudrate of the serial port. Generally you want to configure this at the maximum speed of your USB/UART chip such that data transfers as fast as possible. The ubiquitous FT2232 supports up to 3Mbaud.</p> </li> <li> <p><code>clock_freq</code> (required): The frequency of the clock being provided to the <code>manta</code> module, in Hertz (Hz). This speed doesn't matter much to the logic itself, it's only used to calculate the correct baud timing for the provided baudrate. However, this frequency does have to be fast enough to ensure a good agreement between the onboard prescaler and the requested baudrate - and Manta will throw an error during code generation if that is not the case.</p> </li> </ul>"}]}