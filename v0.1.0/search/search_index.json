{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#manta-a-configurable-and-approachable-tool-for-fpga-debugging-and-rapid-prototyping","title":"Manta: A Configurable and Approachable Tool for FPGA Debugging and Rapid Prototyping","text":"<p>Manta is a tool for getting information into and out of FPGAs over UART or Ethernet. It's primarily intended for debugging and experimentation, but it's robust enough to be a simple, reliable transport layer between a FPGA and a host machine. It works by letting you configure a series of cores, which live as digital logic on the FPGA and are represented with vendor-agnostic Verilog-2001. The information and behavior of these cores are accessible to the host machine, which presents a Python API to the user. Manta includes the following cores, any number and combination of which may be used at once:</p>"},{"location":"#logic-analyzer-core","title":"Logic Analyzer Core","text":"<p>More details available on the full documentation page.</p> <p>This core captures a timeseries of digital signals from within the FPGA, much like a benchtop logic analyzer would. This captures data on the FPGA's native clock and presents it as a waveform, making it very useful for debugging logic cycle-by-cycle. This concept is very similar to the Xilinx Integrated Logic Analyzer (ILA) and Intel SignalTap utilities.</p> <p>You may find this core useful for:</p> <ul> <li> <p>Verifying specification adherence for connected hardware - for instance, you're writing a S/PDIF decoder that works in simulation, but fails in hardware. The logic analyzer core can record a cycle-by-cycle capture of what's coming off the cable, letting you verify that your input signals are what you expect. Even better, Manta will let you play that capture back in your preferred simulator, letting you feed the exact same inputs to your module in simulation and check your logic.</p> </li> <li> <p>Capturing arbitrary data - you're working on a DSP project, and you'd like to grab some test data from your onboard ADCs to start prototyping your signal processing with. Manta will grab that data, and export it for you.</p> </li> </ul>"},{"location":"#io-core","title":"I/O Core","text":"<p>More details available on the full documentation page.</p> <p>This core presents a series of user-accessbile registers to the FPGA fabric, which may be configured as either inputs or outputs. The value of an input register can be read off the FPGA by the host machine, and the value of an output register on the FPGA may be set by the host machine. This is handy for getting small amounts of information into and out of the FPGA, debugging, configuration, or experimentation. This concept is very similar to the Xilinx Virtual IO and Intel In-System Sources and Probes tools.</p> <p>You may find this core useful for:</p> <ul> <li> <p>Prototyping designs in Python, and incrementally migrating them to hardware - you're working on some real-time signal processing, but you want to prototype it with some sample data in Numpy before meticulously implementing everything in Verilog.</p> </li> <li> <p>Making dashboards - you'd like to get some telemetry out of your existing FPGA design and display it nicely, but you don't want to implement an interface, design a packetization scheme, and write a library.</p> </li> </ul>"},{"location":"#block-memory-cores","title":"Block Memory Cores","text":"<p>More details available on the full documentation page.</p> <p>This core creates a two-port block memory on the FPGA, and gives one port to the host machine, and the other to your logic on the FPGA. The width and depth of this block memory is configurable, allowing large chunks of arbitrarily-sized data to be shuffled onto and off of the FPGA by the host machine, via the Python API. This lets you establish a transport layer between the host and FPGA, that treats the data as exactly how it exists on the FPGA.</p> <p>You may find this core useful for:</p> <ul> <li> <p>Moving data between a host and connected FPGA - you're working on a cool new machine learning accelerator, but you don't want to think about how to get training data and weights out of TensorFlow, and into your core.</p> </li> <li> <p>Hand-tuning ROMs - you're designing a digital filter for a DSP project and would like to tune it in real-time, or you're developing a soft processor and want to upload program code without rebuilding a bitstream.</p> </li> </ul>"},{"location":"#dependencies","title":"Dependencies","text":"<p>Manta is written in Python, and generates Verilog-2001 HDL. It's cross-platform, and its only strict dependency is pyYAML. However, pySerial is required for using UART, scapy is required for using Ethernet, and pyvcd is required if you want to export a waveform from the Logic Analyzer core to a <code>.vcd</code> file.</p>"},{"location":"#about","title":"About","text":"<p>Manta and its source code are released under a GPLv3 license, and it was originally developed as part of my Master's Thesis at MIT in 2023, done under the supervision of Dr. Joe Steinmeyer. The thesis itself is copyrighted by Fischer Moseley (me!), but feel free to use the following Bibtex if you'd like to cite it:</p> <pre><code>@misc{manta2023,\n    author={Fischer Moseley},\n    title={Manta: An In-Situ Debugging Tool for Programmable Hardware},\n    year={2023},\n    month={may}\n    howpublished={\\url{https://hdl.handle.net/1721.1/151223}}\n}\n</code></pre>"},{"location":"block_memory_core/","title":"Block Memory Core","text":""},{"location":"block_memory_core/#overview","title":"Overview","text":"<p>Block Memory (also called Block RAM, or BRAM) is the de facto means of storing data on FPGAs when the space needed exceeds a few registers. As a result, Manta provides a Block Memory core, which instantiates a dual-port BRAM on the FPGA. One port is provided to the host, and the other is connected to your logic with the standard BRAM interface (<code>addr</code>, <code>din</code>, <code>dout</code>, <code>wea</code>). This allows the host to provide reasonably large amounts of data to user logic - or the other way around, or a mix of both!</p> <p>This is a very, very simple task - and while configuration is straightforward, there are a few caveats. More on both topics below:</p>"},{"location":"block_memory_core/#configuration","title":"Configuration","text":"<p>Just like the rest of the cores, the Block Memory core is configured via an entry in a project's configuration file. This is easiest to show by example:</p> <pre><code>---\ncores:\n  my_block_memory:\n    type: block_memory\n    width: 12\n    depth: 16384\n</code></pre> <p>There's a few parameters that get configured here, including:</p> <ul> <li><code>name</code>: The name of the Block Memory core. This name is used to reference the core when working with the API, and can be whatever you'd like.</li> <li><code>type</code>: This denotes that this is a Block Memory core. All cores contain a <code>type</code> field, which must be set to <code>block_memory</code> to be recognized as an Block Memory core.</li> </ul>"},{"location":"block_memory_core/#dimensions","title":"Dimensions","text":"<p>The dimensions of the block memory are specified in the config file with the <code>width</code> and <code>depth</code> entries.</p> <p>Manta won't impose any limit on the width or depth of the block memory you instantiate, but since Manta instantiates BRAM primitives on the FPGA, you will be limited by what your FPGA can support. It helps to know your particular FPGA's architecture here.</p> <p>If your BRAM is more than 16 bits wide, check out the section on Synchronicity and make sure your project will tolerate how Manta writes to the block memory.</p>"},{"location":"block_memory_core/#python-api","title":"Python API","text":"<p>The Block Memory core functionality is stored in the <code>Manta.IOCore</code> and <code>Manta.IOCoreProbe</code> classes in src/manta/io_core/__init__.py, and it may be controlled with the two functions:</p> <p>Just like with the other cores, interfacing with the BRAM with the Python API is simple:</p> <pre><code>from manta import Manta\nm = manta('manta.yaml')\n\nm.my_block_memory.write(addr=38, data=600)\nm.my_block_memory.write(addr=0x1234, data = 0b100011101011)\nm.my_block_memory.write(0x0612, 0x2001)\n\nfoo = m.my_block_memory.write(addr=38)\nfoo = m.my_block_memory.write(addr=1234)\nfoo = m.my_block_memory.write(0x0612)\n</code></pre> <p>Reading/writing in batches is also supported. This is recommended where possible, as reads are massively sped up by performing them in bulk:</p> <pre><code>addrs = list(range(0, 1234))\ndatas = list(range(1234, 2468))\nm.my_block_memory.write(addrs, datas)\n\nfoo = m.my_block_memory.read(addrs)\n</code></pre>"},{"location":"block_memory_core/#examples","title":"Examples","text":"<p>A Block Memory core is used in the video_sprite example. This uses the core to store a 128x128 image sprite in 12-bit color, and outputs it to a VGA display at 1024x768. The sprite contents can be filled with an arbitrary image using the send_image.py python script.</p>"},{"location":"block_memory_core/#under-the-hood","title":"Under the Hood","text":"<p>Each Block Memory core is actually a set of 16-bit wide BRAMs with their ports concatenated together, with any spare bits masked off. Here's a diagram:</p> <p></p> <p>This has one major consequence: if the core doesn't have a width that's an exact multiple of 16, synthesis engines (Vivado in particular) will throw some warnings as they optimize out the unused bits. This is expected behavior, and while the warnings are a little annoying, not having to manually deal with the unused bits simplifies the implementation immensely. No Python is needed to generate the core, and it'll configure itself just based on Verilog parameters. This turns the block memory core from a complicated conditionally-instantiated beast to a simple ~100 line Verilog file.</p>"},{"location":"block_memory_core/#address-assignment","title":"Address Assignment","text":"<p>Since each \\(n\\)-bit wide block memory is actually \\(ceil(n/16)\\) BRAMs under the hood, addressing the BRAMs correctly from Manta's internal bus is important. BRAMs are organized such that each 16-bit slice of a \\(N\\)-bit word in the Block Memory core are placed next to each other in bus address space. For instance, a 34-bit wide block memory would exist on Manta's internal bus as:</p> Bus Address Space BRAM Address Space BASE_ADDR + 0 address 0, bits 0-15 BASE_ADDR + 1 address 0, bits 16-31 BASE_ADDR + 2 address 0, bits 32-33 BASE_ADDR + 3 address 1, bits 0-15 BASE_ADDR + 4 address 1, bits 16-31 BASE_ADDR + 5 address 1, bits 32-33 <p>...and so on.</p>"},{"location":"block_memory_core/#synchronicity","title":"Synchronicity","text":"<p>Since Manta's data bus is only 16-bits wide, it's only possible to manipulate the BRAM core in 16-bit increments. This means that if you have a BRAM that's \u226416 bits wide, you'll only need to issue a single bus transaction to read/write one entry in the BRAM. However, if you have a BRAM that's \u226516 bits wide, you'll need to issue a bus transaction to update each 16-bit slice of it. For instance, updating a single entry in a 33-bit wide BRAM would require sending 3 messages to the FPGA: one for bits 1-16, another for bits 17-32, and one for bit 33. If your application expects each BRAM entry to update instantaneously, this could be problematic.</p> <p>There's a few different ways to solve this - you could use an IO core to signal when a BRAM's contents or valid - or you could ping-pong between two BRAMs while one is being modified. The choice is yours, and Manta makes no attempt to presribe any particular approach.</p> <p>Lastly, the interface you use (and to a lesser extent, your operating system) will determine the space between bus transactions. For instance, 100Mbit Ethernet is a thousand times faster than 115200bps UART, so the time where the BRAM is invalid is a thousand times smaller.</p>"},{"location":"ethernet_interface/","title":"Ethernet Interface","text":"<p>This section is under construction!</p> <p>The Ethernet interface is just about to get refactored to implement a few performance gains, so what's here represents the Ethernet interface circa April 2023. Hang tight for new stuff!</p>"},{"location":"ethernet_interface/#overview","title":"Overview","text":"<p>For situations where the onboard UART is not available, Manta provides a 100Mbps Ethernet link for communicating between the host machine and target FPGA. This link implements a L2 MAC on the FPGA, designed to be directly connected to a host machine on a dedicated network adapter. The MAC is controlled by a bridge interface, which performs the exact same function as it does on the UART interface. Incoming packets are parsed into bus transactions, placed on the bus, and any response data is encapsulated into another packet sent to the host.</p> <p>This is done by interacting with an Ethernet PHY, an onboard transceiver IC that converts between the FPGA's logic-level signaling and the voltages on the cable's twisted pairs. The communication between the Ethernet PHY and the FPGA is done over an interface that's dependent on the speed of the PHY. The 10/100 Mbps interface used on the Nexys A7-100T uses the RMII as defined in IEEE 802.3u. RMII is the second-oldest member in the Media Independent Interface family, with newer revisions of 802.3 supporting faster interfaces.</p> <p>Manta's bus clock must be equivalent to the PHY's reference clock if Ethernet is to be used - in the case of the 100Mbps RMII PHY on the Nexys A7 used in 6.205, this is 50MHz. This doesn't pose a problem for user logic, which is connected through Manta's cores that perform CDC internally. It does mean that a reference clock for the PHY has to be synthesized outside of Manta itself, and the means by which this is done varies by FPGA vendor and toolchain.</p> <p>This MAC allows for the usage of packets with the structure shown below. The bus transaction being communicated is placed at the beginning of the packet's payload field, which IEEE 802.3 allows to vary in length from 46 to 1500 bytes. The 46-byte lower limit requires 41 bytes of zero padding to be added to the five bytes used to specify a bus transaction, and only one bus transactions is specified in each Ethernet frame. This abundance of unused space results in all packets being the same length, whether the packet contains a read request, write request, or read response. Packets containing write requests elicit no response from the FPGA, just as write requests delivered over UART produce no response.</p> <p></p> <p>These packets are addressed directly to the host's MAC address, which is obtained during code autogeneration. These packets also use a fixed Ethertype of <code>0x88B5</code>, which is specially reserved for \"public use and for prototype and vendor-specific protocol development\" in IEEE 802.1. This was done to create an Ethernet II frame instead of a legacy 802.3 frame, without having to implement a higher level protocol like TCP or UDP to safely use a fixed Ethertype. This allows the MAC to use modern Ethernet II frames safely, but save FPGA resources.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#overview","title":"Overview","text":"<p>To use Manta, you'll need a host machine with a FPGA board connected over UART or Ethernet. You'll then:</p> <ul> <li>Specify a set of debug cores you wish to include in your design. This is done by writing a configuration file, typically called <code>manta.yaml</code>. Specifying files in JSON is also supported, as long as the hierarchy in the file is equivalent. Just make sure that your YAML files end in <code>.yaml</code> or <code>.yml</code>, and that JSON files end in <code>.json</code>.</li> <li>Invoke Manta to generate Verilog from the configuration provided. This is done by running <code>manta gen [config_file] [verilog_file]</code> at the command line, which generates a Verilog file (typically named <code>manta.v</code>) from the provided configuration file. This Verilog file contains a definition for a Verilog module named <code>manta</code>, and all its constituent modules.</li> <li>Instantiate <code>manta</code> in your design, and connecting it to the logic you'd like to debug. An example instantiation is provided at the top of <code>manta.v</code>, which you can copy-paste into your main source code. You'll connect its ports to the logic you're trying to debug, as well as to whatever interface you're using to communicate with the host. This will be a serial transciever on your development board if you're using UART, or it's RMII PHY if you're using Ethernet.</li> <li>Build and upload the design to your FPGA using your preferred toolchain.</li> <li>Use the debug core(s) through the Python API or the command line. The functions availble to each core are described in their documentation.</li> <li>Repeat! As you debug, you'll probably want to change exactly how Manta is configured. This means tweaking the configuration file, regenerating the Verilog module, and so on.</li> </ul>"},{"location":"getting_started/#example-configuration","title":"Example Configuration","text":"<p>An example config file is provided below. If this file was named <code>manta.yaml</code> then running <code>manta gen manta.yaml manta.v</code> would generate Verilog for a <code>manta</code> module that matched the config file.</p> <pre><code>---\ncores:\n  my_io_core:\n    type: io\n\n    inputs:\n      probe_0_in: 6\n      probe_1_in: 12\n\n    outputs:\n      probe_2_out: 20\n      probe_3_out: 1\n\n  my_logic_analyzer:\n    type: logic_analyzer\n    sample_depth: 4096\n    trigger_loc: 1000\n\n    probes:\n      larry: 1\n      curly: 3\n      moe: 9\n\n    triggers:\n      - moe RISING\n      - curly FALLING\n\nuart:\n  port: \"auto\"\n  baudrate: 3000000\n  clock_freq: 100000000\n</code></pre> <p>Although it's just an example, this config file shows the two things every Manta configuration needs, namely:</p> <ul> <li> <p>Cores: A list of the debug cores Manta should place on your FPGA. The behavior and configuration of the cores is described in more detail on their documentation pages, but this list contains each core you'd like included in your <code>manta</code> module. This list can have as many entires as your FPGA can support, so long as Manta can address them all. If it can't, it'll throw an error when it tries to generate Verilog.</p> </li> <li> <p>Interface: The way data gets on and off the FPGA. At present, Manta only supports UART and Ethernet interfaces. These are described in more detail on their documentation pages, but the interface of choice is specified with either a <code>uart</code> or <code>ethernet</code> at the end of the configuration file.</p> </li> </ul> <p>This Manta instance has an IO Core and a Logic Analyzer, each containing a number of probes at variable widths. The Manta module itself is provided a 100MHz clock, and communicates with the host over UART running at 3Mbaud. This is just an example, and more details are available in the documentation page for each core.</p>"},{"location":"getting_started/#example-instantiation","title":"Example Instantiation","text":"<p>The Verilog file generated by <code>manta gen</code> contains some information at the top of the file. This includes an example instantiation for the <code>manta</code> module that's been configured, which you can copy paste into your source code. Here's what that looks like for the configuration above:</p> <pre><code>/*\nThis module was generated with Manta v0.0.5 on 11 Sep 2023 at 17:52:28 by fischerm\n\nIf this breaks or if you've got spicy formal verification memes, contact fischerm [at] mit.edu\n\nProvided under a GNU GPLv3 license. Go wild.\n\nHere's an example instantiation of the Manta module you configured, feel free to copy-paste\nthis into your source!\n\nmanta manta_inst (\n    .clk(clk),\n\n    .rx(rx),\n    .tx(tx),\n\n    .probe_0_in(probe_0_in),\n    .probe_1_in(probe_1_in),\n    .probe_2_out(probe_2_out),\n    .probe_3_out(probe_3_out),\n\n\n    .larry(larry),\n    .curly(curly),\n    .moe(moe));\n\n*/\n</code></pre>"},{"location":"how_it_works/","title":"How It Works","text":""},{"location":"how_it_works/#system-architecture","title":"System Architecture","text":"<p>The whole system looks like the following:</p> <p></p> <p>Manta is operated via its Python API, which communicates with the connected FPGA over an interface API like <code>pySerial</code> or <code>Scapy</code>. These abstract away the OS device drivers, which function differently depending on the host machine's platform. The OS device drivers ultimately send out bytes to the FPGA, across either a USB or Ethernet cable.</p> <p>Once sent across the wire, bytes are picked up by an interface transciever on the FPGA development board. This is either a USB-UART converter or a RMII PHY depending on if you're using UART or Ethernet. This chip is connected to the FPGA's IO, which routes the signals to the Verilog module generated by Manta. This module parses incoming messages, passes them down a set of daisy-chained cores, and then packetizes it and sends it back to the host.</p>"},{"location":"how_it_works/#manta-architecture","title":"Manta Architecture","text":"<p>The logic Manta places on the FPGA consists of a series of cores connected in a chain along a common bus. Each core provides a unique method for interacting with the user\u2019s logic, which it connects to by routing signals (called probes) between the user\u2019s logic and the cores that interface with it.</p> <p></p> <p>These probes are presented as addressable memory, and are be controlled by reading and writing to their corresponing memory - not unlike registers on a microcontroller. Each core is allotted a section of address space at compile time, and operations addressed to a core\u2019s address space control the behavior of the core. These cores are then daisy-chained along an internal bus, which permits a chain arbitrarily many cores to be placed on the bus.</p> <p>At the beginning of this chain is a module called a receive bridge, which converts incoming UART/Ethernet communication from the host into read and write requests, which are placed on the bus. These are called bus transactions, and once placed on the bus, they travel through each core before reaching the transmit bridge at the end of the chain. This module places the result of the bus transaction back on the UART/Ethernet interface, and sends it back to the host. This produces a request-response style of communication between the host machine and the FPGA.</p>"},{"location":"how_it_works/#data-bus","title":"Data Bus","text":"<p>The data bus is designed for simplicity, and consists of five signals used to perform reads and writes on memory:</p> <ul> <li><code>addr [15:0]</code>, indicating the memory address targeted by the current transaction.</li> <li><code>data [15:0]</code>, which data is read from during a read, or written to during a write.</li> <li><code>rw</code>, indicating a read or write transaction if the signal is low or high respectively.</li> <li><code>valid</code>, which is driven high only when the operation specified by the other signals is to be executed.</li> </ul> <p>Each core has a bus input and output port, so that cores can be daisy-chained together. When it receives an incoming bus transaction (signalled by <code>valid</code>), the core checks the address on the wire against its own memory space. If the address lies within the core, the core will perform the requested operation against its own memory space. In the case of a read, it places the data at that address on <code>data</code>, and in the case of a write, it copies the value of <code>data</code> to the specified location in memory. However, if the address lies outside of the memory of the core, then no operations are performed.</p> <p> </p>"},{"location":"how_it_works/#message-format","title":"Message Format","text":"<p>Ethernet and UART both allow a stream of bytes to be sent between the host and FPGA, but since they're just interfaces, they don't define how these bytes are structured. As a result, Manta implements its own messaging format, with the following structure:</p> <p></p> <p>Each of these messages is a string of ASCII characters consisting of a preamble, optional address and data fields, and an End of Line (EOL). The preamble denotes the type of operation, R for a read and W for a write. The address and data fields are encoded as hexadecimal digits, represented with the characters 0-9 and A-F in ASCII. As a result, four characters are needed to encode a 16-bit address or 16-bits of data. If the message specifies a write request, then it will contain a data field after the address field. Both request types will conclude with an End of Line, which consists of the two ASCII characters indicating a Carriage Return (CR) and a Line Feed (LF).</p> <p>These requests are sent by the host machine to the FPGA, which reads them from the <code>rx</code> line on the interface transceiver. This is handled by the receive bridge, which parses incoming messages, and generates bus transactions from them. Once this transaction runs through every core in the chain, it arrives at the transmit bridge, which may send a response back to the host over the <code>tx</code> line.</p> <p>If the request specified a read operation, then a response will be produced. These responses have the same structure as the read request itself, albeit with the data read from memory substituted in place of the address. This results in a message of the same length, just with the address swapped for data. If the request specified a write operation, then no response will be sent back to the host. Manta provides no report of if the write was successful - if a write operation must be verified, Manta will just perform a read operation on the same address location and check the value.</p> <p>An example of some bus traffic is provided below:</p> Sequence Number Interface Activity Operation 1 Host \u2192 FPGA: R1234(CR)(LF) - 2 FPGA \u2192 Host: R5678(CR)(LF) Read 0x5678 from 0x1234 3 Host \u2192 FPGA: WF00DBEEF(CR)(LF) Write 0xBEEF to 0xF00D 4 Host \u2192 FPGA: RF00D(CR)(LF) - 5 FPGA \u2192 Host: RBEEF(CR)(LF) Read 0xBEEF from 0xF00D 6 Host \u2192 FPGA: W12340000(CR)(LF) Write 0x0000 to 0x1234 <p>When UART is used, these bytes are transmitted directly across the wire, but when Ethernet is used, they're packed into the packet's payload field.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>Manta requires the following dependencies:</p> <ul> <li>pyYAML, which is used for parsing configuration files written in YAML.</li> <li>pySerial, used for communicating with the FPGA over UART.</li> <li>Scapy, used for communicating with FPGA over Ethernet.</li> <li>pyVCD, used for writing waveforms captured by the Logic Analyzer Core to standard Value Change Dump (VCD) files.</li> </ul> <p>All of these dependencies are technically optional. If you're comfortable writing configuration files in JSON, then you don't need pyYAML. If you're using UART exclusively in your project, then you won't need Scapy. That said, Manta will try to install (or use an existing copy of) pyYAML, pySerial, and pyVCD during its own installation to cover all use cases.</p>"},{"location":"installation/#installation","title":"Installation","text":"<p>You can install the latest version of Manta directly from source with:</p> <pre><code>pip install git+https://github.com/fischermoseley/manta.git\n</code></pre> <p>Note for Ubuntu users:</p> <p>If you're on Ubuntu, you'll probably need to run this first to dodge a bug in the current version of Python's <code>setuptools</code>: <pre><code>export DEB_PYTHON_INSTALL_LAYOUT=deb_system\n</code></pre> Do this before installing Manta. If you've already installed it, just uninstall, run the above command, and then reinstall.</p> <p>It's recommended to place Manta on your system path by adding <code>export PATH=\"~/.local/bin:$PATH\"</code> to your <code>.bashrc</code> or <code>.zshrc</code>. This isn't strictly necessary, but it means that Manta (and any other executable Python modules) can be run as just <code>manta</code> on the command line, instead of <code>python3 -m manta</code>. If you're on Windows, this location will likely be different.</p> <p>Feel free to install Manta within a virtual environment (venv, Conda, and so on) if you'd like!</p> <p>Later Manta will be availabe on the PyPI lists, and you'll be able to just <code>pip install mantaray</code>, but that's not configured quite yet.</p>"},{"location":"io_core/","title":"IO Core","text":""},{"location":"io_core/#overview","title":"Overview","text":"<p>Registers are a fundamental building block of digital hardware, and the IO core provides a simple way of interacting with them from the host machine. It allows you to define a set of inputs and outputs of arbitrary width, and then set values to the outputs and read values from the inputs.</p> <p>This is a very, very simple task - and while configuration is straightforward, there are a few caveats. More on both topics below:</p>"},{"location":"io_core/#configuration","title":"Configuration","text":"<p>Just like the rest of the cores, the IO core is configured via an entry in a project's configuration file. This is easiest to show by example:</p> <p><pre><code>---\nmy_io_core:\n  type: io\n\n  inputs:\n    kermit: 3\n    piggy: 1\n    animal: 38\n    scooter:\n      width: 4\n      initial_value: 13\n\n  outputs:\n    fozzy: 1\n    gonzo: 3\n\n  user_clock: True\n</code></pre> Inside this configuration, the following parameters may be configured:</p> <ul> <li><code>name</code> (required): The name of the IO core. This name is used to reference the core when working with the API, and can be whatever you'd like.</li> <li><code>type</code> (required): This denotes that this is an IO core. All cores contain a <code>type</code> field, which must be set to <code>io</code> to be recognized as an IO core.</li> <li><code>inputs</code> (optional): This lists all inputs from from the FPGA fabric to the host machine. Signals in this list may be read by the host, but cannot be written to. Technically specifying input probes is totally optional - it's perfectly fine to have an IO core with only output probes.</li> <li><code>outputs</code> (optional): This lists all outputs from the host machine to the FPGA fabric. Signals in this list are usually written to by the host, but they can also be read from. Doing so returns the value last written to the register. Just like the <code>inputs</code> parameter, this list is techically optional, and it's perfectly valid to have an IO core with input probes only.<ul> <li><code>initial_value</code> (optional): This sets an initial value for an output probe to take after the FPGA powers on. This is done with an <code>initial</code> statement in Manta's Verilog, and is independent of the input clock or resets elsewhere in the FPGA. This parameter is optional, and if it isn't provided the probe will initialize to zero.</li> </ul> </li> <li><code>user_clock</code> (optional): If set to True, an extra input port will be added to the <code>manta</code> module for an clock input to run the IO core on. This lets the IO Core handle clock domain crossing through its internal buffers. If set to False, Manta will run the IO core from its internal clock (the one provided through <code>manta</code>'s <code>clk</code> port). More information on this is available in the diagram below. This parameter is optional, and defaults to False.</li> </ul> <p>Name things carefully!</p> <p>The names of the core and its probes are referenced in the autogenerated Verilog. This means that while the names can be arbitrary, they must be unique within your project and not contain any characters that your synthesis engine won't appreciate.</p>"},{"location":"io_core/#python-api","title":"Python API","text":"<p>The IO core functionality is stored in the <code>Manta.IOCore</code>, <code>Manta.InputProbe</code>, and <code>Manta.OutputProbe</code> classes in src/manta/io_core/__init__.py, and it may be controlled with the two functions:</p> <p><code>Manta.IOCoreProbe.set(data)</code></p> <ul> <li>[<code>int</code>, <code>bool</code>] data: The value to write to an output probe. May be signed or unsigned, but will raise an exception if the value is too large for the width of the port.</li> <li>returns: None</li> </ul> <p>This method is blocking. When called it will dispatch a request to the FPGA, and wait until a response has been receieved.</p> <p><code>Manta.IOCoreProbe.get()</code></p> <ul> <li>returns: The value of an input or output probe. In the case of an output probe, the value returned will be the last value written to the probe.</li> </ul> <p>This method is blocking. When called it will dispatch a request to the FPGA, and wait until a response has been receieved.</p>"},{"location":"io_core/#example","title":"Example","text":"<p>A small example is shown below, using the example configuration above. More extensive examples can also be found in the repository's examples/ folder.</p> <pre><code>&gt;&gt;&gt; import Manta\n&gt;&gt;&gt; m = Manta\n&gt;&gt;&gt; m.my_io_core.fozzy.set(True)\n&gt;&gt;&gt; m.my_io_core.fozzy.get()\nTrue\n&gt;&gt;&gt; m.my_io_core.gonzo.set(4)\n&gt;&gt;&gt; m.my_io_core.scooter.get()\n5\n</code></pre>"},{"location":"io_core/#caveats","title":"Caveats","text":"<p>While the IO core performs a very, very simple task, it carries a few caveats.</p> <ul> <li> <p>First, it's not instantaneous. Manta has designed to be as fast as possible, but setting and querying registers relies on passing messages between the host and FPGA, which is slow relative to FPGA clock speeds! If you're trying to set values in your design with cycle-accurate timing, this will not do that for you. However, the Logic Analyzer's playback feature might be helpful.</p> </li> <li> <p>Second, the API methods are blocking, and will wait for a response from the FPGA before resuming program execution. Depending on your application, you might want to run your IO Core operations in a seperate thread, but you can also decrease the execution time by using a faster interface between the host and FPGA. This means using a higher UART baudrate, or using Ethernet.</p> </li> </ul>"},{"location":"io_core/#how-it-works","title":"How It Works","text":"<p>This is done with the architecture shown below:</p> <p></p> <p>Each of the probes is mapped to a register of Manta's internal memory. Since Manta's internal registers are 16 bits wide, probes less than 16 bits are mapped to a single register, but probes wider than 16 bits require multiple.</p> <p>Whatever the number of registers required, these are read from and written to by the host machine - but the connection to the user's logic isn't direct. The value of each probe is buffered, and only once the <code>strobe</code> register has been set to one will the buffers update. When this happens, output probes provide new values to user logic, and new values for input probes are read from user logic. This provides a convenient place to perform clock domain crossing, and also mitigates the possibility of an inconsistent system state. This is explained in more detail in Chapter 3.6 of the original thesis.</p>"},{"location":"logic_analyzer_core/","title":"Logic Analyzer Core","text":""},{"location":"logic_analyzer_core/#overview","title":"Overview","text":"<p>The Logic Analyzer core allows for debugging logic by capturing a set of digital signals to memory. This is done in response to a trigger condition, which starts the capture, which continues until the onboard memory is full, and the resulting capture is then read out to the user.</p> <p>While this is pretty much identical to the behavior of a benchtop logic analyzer, Manta has a few tricks up its sleeve that you may find useful! These are described below:</p>"},{"location":"logic_analyzer_core/#configuration","title":"Configuration","text":"<p>Just like the rest of the cores, the Logic Analyzer core is configured via an entry in a project's configuration file. This is easiest to show by example:</p> <pre><code>---\ncores:\n  my_logic_analyzer:\n    type: logic_analyzer\n    sample_depth: 4096\n    trigger_loc: 1000\n\n    probes:\n      larry: 1\n      curly: 3\n      moe: 9\n\n    triggers:\n      - moe RISING\n      - curly FALLING\n</code></pre> <p>There's a few parameters that get configured here, including:</p> <ul> <li><code>name</code>: The name of the Logic Analyzer core. This name is used to reference the core when working with the API, and can be whatever you'd like.</li> <li><code>type</code>: This denotes that this is a Logic Analyzer core. All cores contain a <code>type</code> field, which must be set to <code>logic_analyzer</code> to be recognized as an Logic Analyzer core.</li> </ul>"},{"location":"logic_analyzer_core/#sample-depth","title":"Sample Depth","text":"<p>This refers to the number of samples saved in the capture, and is set with the <code>sample_depth</code> entry in the config file. A larger sample depth will use more resources, but show what your probes are doing over a longer time.</p>"},{"location":"logic_analyzer_core/#probes","title":"Probes","text":"<p>Probes are the signals in your logic that the Logic Analyzer connects to, and are specified in the <code>probes</code> entry of the config file. Each probe requires both a name and a width to be specified. These names can be whatever you'd like, however they are referenced in the autogenerated Verilog - so don't use something your synthesis engine won't appreciate.</p>"},{"location":"logic_analyzer_core/#triggers","title":"Triggers","text":"<p>Triggers are the conditions that your logic must meet in order to start a capture, and they're specified under the <code>triggers</code> entry in the config file. Manta's triggers are reprogrammable, meaning you don't need to rebuild your source code to change the trigger condition - just updating the configuration file is enough. If multiple triggers are provided, any one trigger being met will trigger the entire core.</p> <p>Each individual trigger is specified with the following structure:</p> <p><code>[probe]</code> <code>[operation]</code> <code>[argument]</code></p> <ul> <li> <p>probe: The probe that the trigger applies to. Each probe only supports one trigger on it. For instance, in the example above we couldn't add a trigger for <code>curly LEQ 4</code>, since we've already assigned a trigger to <code>curly</code>.</p> </li> <li> <p>operation: The logical operation to perform. Manta supports the following operations:</p> <ul> <li><code>RISING</code>, which checks if the probe has increased in value since the last clock cycle.</li> <li><code>FALLING</code>, which checks if the probe has decreased in value since the last clock cycle.</li> <li><code>CHANGING</code>, which checks if the probe is changed in value since the last clock cycle.</li> </ul> <p>These operations only compare a probe's value with itself, but sometimes it is useful to compare a probe's value to a constant. Manta provides a operations for doing such, including:</p> <ul> <li><code>GT</code>,  for greater than.</li> <li><code>LT</code>,  for less than.</li> <li><code>GEQ</code>, for greater than or equal to.</li> <li><code>LEQ</code>, for less than or equal to.</li> <li><code>EQ</code>, for equal to.</li> <li><code>NEQ</code>, for not equal to.</li> </ul> <p>These operations require a constant to compare against, referred to as an argument, which is descirbed below:</p> </li> <li> <p>argument: A constant to compare against, if the operation specified requires one. On the FPGA, the argument will have just as many bits as the probe width.</p> </li> </ul> <p>Lastly, if you're not able to express your desired trigger condition in terms of the operators above, fear not! You can also specifiy an <code>external_trigger: true</code> entry in the config file, which exposes an input on Manta's top level for your own trigger.</p>"},{"location":"logic_analyzer_core/#trigger-position-optional","title":"Trigger Position (optional)","text":"<p>Sometimes, you care more about what happens before a trigger is met than afterwards, or vice versa. To accomodate this, the logic analyzer has an optional Trigger Position parameter, which sets when probe data is captured relative to the trigger condition being met. This is specified with the <code>trigger_position</code> entry in the configuration file, which sets how many samples to save prior to the trigger condition occuring. This is best explained with a picture:</p> <p></p> <p>The windows at the bottom of the diagram show what portions of the timeseries will be captured for different trigger positions. For instance:</p> <ul> <li>A trigger position of half the sample depth centers the capture window around when the trigger condition is met.</li> <li>A trigger position of zero places the trigger at the zeroth clock cycle of the capture.</li> <li>A trigger position equal to the sample depth causes the trigger to occur on the last sample in the capture.</li> </ul> <p>If <code>trigger_position</code> is not specified, Manta will default to centering the capture window around the trigger condition.</p>"},{"location":"logic_analyzer_core/#capture-modes-optional","title":"Capture Modes (optional)","text":"<p>The logic analyzer has a few different ways of capturing data, which are represented by the capture modes below:</p> <ul> <li>Single-Shot: Once the trigger condition is met, record the value of the probes on every clock cycle in a continuous single shot.</li> <li>Incremental: Record samples when the trigger condition is met, but don't record the samples when the trigger condition is not met. This is super useful for applications like audio processing or memory controllers, where there are many system clock cycles between signals of interest.</li> <li>Immediate: Record the value of the probes on every clock cycle, beginning immediately, and regardless of if the trigger condition is met. This is useful for investigating cases where a trigger condition is never being met (such as latchup or deadlock conditions) or obtaining a random snapshot of the FPGA's state.</li> </ul> <p>Most logic analyzers use a single-shot capture by default, so Manta will do the same if no <code>capture_mode</code> entry is provided in the project's configuration file.</p>"},{"location":"logic_analyzer_core/#usage","title":"Usage","text":""},{"location":"logic_analyzer_core/#capturing-data","title":"Capturing Data","text":"<p>Once you have your Logic Analyzer core on the FPGA, you can capture data with:</p> <pre><code>manta capture [config file] [LA core] [path] [path]\n</code></pre> <p>If the file <code>manta.yaml</code> contained the configuration above, and you wanted to export a .vcd and .mem of the captured data, you would execute:</p> <pre><code>manta capture manta.yaml my_logic_analyzer capture.vcd capture.mem\n</code></pre> <p>This will reset your logic analyzer, configure it with the triggers specified in <code>manta.yaml</code>, and perform a capture. The resulting .vcd file can be opened in a waveform viewer like GTKWave, and the <code>.mem</code> file can be used for playback as described in the following section.</p> <p>Manta will stuff the capture data into as many files as you provide it on the command line, so if you don't want the <code>.mem</code> or <code>.vcd</code> file, just omit their paths.</p>"},{"location":"logic_analyzer_core/#playback","title":"Playback","text":"<p>The Logic Analyzer Core has the ability to capture a recording of a set of signals on the FPGA, and then 'play them back' inside a Verilog simulation. This requires generating a small Verilog module that loads a capture from a <code>.mem</code> file, which can be done by:</p> <pre><code>manta playback [config_file_path] [core_name] [verilog_file_path]\n</code></pre> <p>If the file <code>manta.yaml</code> contained the configuration above, then running:</p> <pre><code>manta playback manta.yaml my_logic_analyzer sim/playback.v\n</code></pre> <p>Generates a Verilog wrapper at <code>sim/playback.v</code>, which can then be instantiated in the testbench in which it is needed. An example instantiation is provided at the top of the output verilog, so a simple copy-paste into the testbench is all that's necessary to use the module. This module is also fully synthesizable, so you can use it in designs that live on the FPGA too, if so you so wish.</p> <p>This is useful for two situations in particular:</p> <ul> <li> <p>Input Verification. Designs will often work in simulation, but fail in hardware. In the absence of any build errors, this usually means that the inputs being applied to the logic in simulation don't accurately represent those being applied to the logic in the real world. Playing signals back in simulation allows for easy comparison between simulated and measured input, and provides a nice way to check that the logic downstream is behaves properly.</p> </li> <li> <p>Sparse Sampling Sometimes designs will have a small number of inputs, but a huge amount of internal state. In situations like these, it may be more effecient to sample the inputs and simulate the logic, instead of directly sampling the state. For instance, debugging a misbehaving branch predictor in a CPU can be done by recording activity on the address and data busses and playing them back in simulation - which would use less BRAM than sampling the entire pattern history table.</p> </li> </ul>"},{"location":"logic_analyzer_core/#python-api","title":"Python API","text":"<p>The Logic Analyzer core functionality is stored in the <code>Manta.LogicAnalyzerCore</code> class in src/manta/la_core/__init__.py.</p> <p>At present, this class contains methods used really only for capturing data, and exporting <code>.vcd</code> and <code>.mem</code> files. It'd be super handy to expose the data from the logic analyzer core in a Pythonic way - which is why the feature is on the roadmap!</p>"},{"location":"logic_analyzer_core/#how-it-works","title":"How It Works","text":"<p>The Logic Analyzer Core's implementation on the FPGA consists of three primary components:</p> <p></p> <ul> <li>The Finite State Machine (FSM), which controls the operation of the core. The FSM's operation is driven by its associated registers, which are placed in a separate module. This permits simple CDC between the bus and user clock domains.</li> <li>The Trigger Block, which generates the core's trigger condition. The trigger block contains a trigger for each input probe, and the registers necessary to configure them. It also contains the \\(N\\)-logic gate (either AND or OR) that generates the core's trigger from the individual probe triggers. CDC is performed in exactly the same manner as the FSM. If an external trigger is specified, the trigger block is omitted from the Logic Analyzer Core, and the external trigger is routed to the FSM's <code>trig</code> input.</li> <li>The Sample Memory, which stores the states of the probes during a capture. This is implemented as a dual-port, dual-clock block memory, with the bus on one port and the probes on the other. The probe-connected port only writes to the memory, with the address and enable pins managed by the FSM. CDC is performed in the block RAM primitive itself. \\end{itemize}</li> </ul>"},{"location":"repository_structure/","title":"Repository Structure","text":""},{"location":"repository_structure/#repository-structure","title":"Repository Structure","text":"<ul> <li><code>src/manta/</code> contains the Python and Verilog source needed to generate and run the cores.</li> <li><code>test/</code> contains testbenchs for HDL. Manta is written in Verilog 2001, but the testbenches are written in SystemVerilog 2012. These are simulated using Icarus Verilog, which produces <code>.vcd</code> files, viewable with your favorite waveform viewer, like GTKWave.</li> <li><code>doc/</code> contains the documentation you're reading right now! It's built into a nice static site by Material for MkDocs, which automatically rebuilds the site on every commit to <code>main</code>. This is done with a GitHub Action configured in <code>.github/</code></li> <li><code>examples/</code> is exactly what it sounds like. It contains examples for both the Digilent Nexys 4 DDR/Nexys A7 with thier onboard Series-7, as well as the Icestick with its onboard iCE40.</li> <li><code>.github/</code> also contains some GitHub Actions configuration for automatically running the SystemVerilog testbenches and building the examples, in addition to automatically rebuilding the site.</li> </ul>"},{"location":"repository_structure/#tools-used","title":"Tools Used","text":"<ul> <li>Icarus Verilog is used for functional simulation.</li> <li>The YosysHQ tools and Vivado are used for building bitstreams.</li> <li>Wavedrom is used for for waveform diagrams, and draw.io for block diagrams</li> <li>GitHub Pages is used to serve the documentation site, which is built with Material for MkDocs.</li> <li>GitHub Actions is used for continuous integration.</li> </ul>"},{"location":"repository_structure/#github-actions-setup","title":"GitHub Actions Setup","text":"<p>Since Vivado is large and requires individual licenses it's run on a private server, which is configured as a self-hosted runner in GitHub Actions. This is a virtual server hosted with KVM/QEMU and managed by libvirt, which is configured as transient so that it reloads its state from a snapshot periodically. A Nexys A7 and Icestick are connected to the physical machine and passthrough-ed to this VM so that continuous integration can check against real hardware.</p>"},{"location":"uart_interface/","title":"UART Interace","text":""},{"location":"uart_interface/#overview","title":"Overview","text":"<p>Manta needs an interface to pass data between the host machine and FPGA, and UART is a convenient option. When configured to use UART, Manta will shuffle data back and forth using generic 8N1 serial with no flow control. This happens through a series of read and write transactions, which are specified using a messaging format described here.</p>"},{"location":"uart_interface/#configuration","title":"Configuration","text":"<p>The configuration of the UART interface is best shown by example:</p> <p><pre><code>uart:\n  port: \"auto\"\n  baudrate: 3000000\n  clock_freq: 100000000\n</code></pre> This snippet defines the interface, and lives at the bottom of a Manta configuration file. Three parameters must be set:</p> <ul> <li> <p><code>port</code> (required): The name of the serial port on the host machine that's connected to the FPGA. Depending on your platform, this could be <code>/dev/ttyUSBXX</code>, <code>/dev/tty.usbserialXXX</code>, or <code>COMX</code>. If set to <code>auto</code>, then Manta will try to find the right serial port by looking for a USB device with the same VID and PID as a FT2232 - a USB/UART converter chip that's super popular on FPGA dev boards. This doesn't always work, but it's super convenient when it does. If your port isn't automatically detected, then just specify the port manually.</p> </li> <li> <p><code>baudrate</code> (required): The baudrate of the serial port. Generally you want to configure this at the maximum speed of your USB/UART chip such that data transfers as fast as possible. The ubiquitous FT2232 supports up to 3Mbaud.</p> </li> <li> <p><code>clock_freq</code> (required): The frequency of the clock being provided to the <code>manta</code> module, in Hertz (Hz). This speed doesn't matter much to the logic itself, it's only used to calculate the correct baud timing for the provided baudrate. However, this frequency does have to be fast enough to ensure a good agreement between the onboard prescaler and the requested baudrate - and Manta will throw an error during code generation if that is not the case.</p> </li> </ul>"}]}